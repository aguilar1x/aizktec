{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "NFT",
  "functions": [
    {
      "name": "public_get_symbol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACSHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAAC7HgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAAzS8MAAIAASYoAIAEBHgADQAAAIAEgAMkAIADAAAAuioBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF0E3qz6yL/WM8AQECJi4AGMoYyg==",
      "debug_symbols": "vZXdqsIwDMffpde7aJKmH77KQWRqlcHYZM4DB/HdTyvrnDqciOxmLOOX/dN8NGex9evTflVUu/ooFj9nUdabvC3qKljnSybWTVGWxX41/CxkfBi+8sdDXkXz2OZNKxagrJSZ8NU2vjvi8I9dUfpgEV6yZ14iJlwqvNHoRmilFXe00qx62tIIbJV1HWxZ8hBeZsLK74TvkgYAuBnD/1L22fbZt1PZBzYm0ZrodfiOTTqr02Afwnf07fAB78OPInYGEZB6DhWAcRVpoFeRjiZUTEA63ITWnaggKp0qiNo9VBBAvxPR/bmjH8KHfh/qkfrQz435KeSUQYXmVqc4zU8wsUqXG+nBCIOVYy2ANk0M0IBGGKMN69Qwhu1EKQ3pNLlGSf0aBgjB9r1I7m7Ql5dg/eZNka9L3+2I3anaDFZG+3fwD9vj0NQbvz01Pu6R2wqBeAejyQivDRUMoow4aASdfw==",
      "brillig_names": [
        "public_get_symbol"
      ]
    },
    {
      "name": "mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "mint"
      ]
    },
    {
      "name": "private_get_symbol",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18192277837884173995": {
            "error_kind": "string",
            "string": "Function private_get_symbol can only be called statically"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3bjiS7kaz9LrpeF8EzOa8y2BjMQXsgQJAGGs0P/Bjo3Xd2ZUVk9kp2siqKrHTSP10I3b2CSQ8zc9JpQUb87x/+44//9j//+S9/+sv//et//+Gf/vl///Dnv/77v/79T3/9y+Vv//sHY9/+7b//61//8uOv//33f/3b3//wT9Zb99sf/viX/7j8MYTwj9/+8H//9Oc//uGfjLP/+O3ham9CeL/am2KOq7P9x//57Q/GDe/B13owPm/beyPji2v1cflXs1/uQrxdbUvt6s25tF++ueDvY3q83LrN779++XPafn8LYf5biNVbcOV2C66E7adb+NEsVZsF53d9mOBzeWiWa828S3HXyaWzo9GPe3u8eIuHqKxztx7yVkMrbQe2yd+wsmZ7i6fIisduwuIxwuKxwuJxwuLxwuIJwuKJwuJJ3xyPdcXus4GP5SGe7x6f7SWKI57yMz61uc8fs9IWbePqVPweSSrlFonNtXn1MvMeYd+mO1u7RZtM2YNOd7dYvdikAzyT7sCrX7wdv3y5wXx/8Q92CuzIZcdtsCOYne+uZGww8bZUcg28i0k1coyJlYuzNXsg2QbbIGc9Ki1UrkKlg8pVqPRQuQqVQTSVxmZ/2GvW/MTlj+jj1NEn2dGXm/lYomvk0SUd9jQy91kUq9WsOaxla9NPV//AJYNLFZcCLjVc/KYWF3c4PNY/4iJ7HfQ6XGQvKl6Hi+wKfSQu4YZLMg+4eHCp4iK8dnwZLsKr0pHz9B0u9gEXvfXucYvWlviAi9569zkueuvdp7gEvfXu3fhSHuqXsFK9m+PtEc7dtqI6MONsKXt7huy2ltPkDnqMc+YrtlRYqURXTuVKqwohVL7ILA4eKlehcqW1WzcqfwAjffFmjkcK5S6QXxRXfkcx3Sug1ER7QWuP2uZ897Aiv8Eife32IlikL91eBIv0ldtrYInSF24vgkX6uu1FsEhfA70IFunriRfB4oGlBov0OvdFsFDlVmGhyq3CQpVbhYUqtwZLosqtwkKVW4WFKrcKC1VuFRYPLDVYqHKrsFDlVmGhyq3CQpVbhYUqtwZLpsqtwkKVW4WFKrcKC1VuFRYPLDVYqHKrsFDlVmGhyq3CQpVbhYUqtwZLocqtwkKVW4WFKrcKC1VuFRYPLDVYqHKrsFDlVmGhyq3CslKVe7vTnLefYPlxpysVrk/v1GwrFaMl3l5StZmG2IOz+1mO4MJdauh4SdXlv8K8UuZXWlLA/GeYX2nVBPOfYd7DvFLmV1r7wvxnmF9peQ/zn2F+JQcD5j/D/EomDcx/hvmVTCuY/wTzBg9PK/N4eFqZx8PTyjwenlbmPcwrZR4PTyvzeHhamcfD08o8Hp5W5vHwlDJv8fC0Mo+Hp5V5PDytzOPhaWXew7xS5vHwtDKPh6eVeTw8rczj4WllHg9PKfMOD08r83h4WpnHw9PKPB6eVuY9zCtlHg9PK/N4eFqZx8PTyjwenlbm8fCUMu/x8LQyj4enlXk8PK3M4+FpZd7DvFLm8fC0Mo+Hp5V5PDytzOPhaWUeD08p8wEPTyvzeHhamcfD08o8Hp5W5j3MK2UeD08r83h4WpnHw9PKPB6eVubx8JQyH/HwtDKPh6eVeTw8rczj4Wll3sO8Uubx8LQyj4enlXk8PK3M4+FpZR4PTynzCQ9PK/N4eFqZx8PTyjwenlbmPcwrZR4PTyvzeHhamcfD08o8Hp5W5vHwlDKf8fC0Mo+Hp5V5PDytzOPhaWXew7xS5vHwtDKPh6eVeTw8rczj4WllHg9PKfMFD08r83h4WpnHw9PKPB6eVuY9zCtlHg9PK/N4eFqZx8PTyjwenlbm8fB0Mm83PDytzOPhaWUeD08r83h4Wpn3MK+UeTw8rczj4WllHg9PK/N4eFqZx8NTyrzBw9PKPB6eVubx8LQyj4enlXkP80qZx8PTyjwenlbm8fC0Mo+Hp5V5PDylzFs8PK3M4+FpZR4PTyvzeHhamfcwr5R5PDytzOPhaWUeD08r83h4WpnHw1PKvMPD08o8Hp5W5vHwtDKPh6eVeQ/zSpnHw9PKPB6eVubx8LQyj4enlXk8PKXMezw8rczj4WllHg9PK/N4eFqZ9zCvlHk8PK3M4+FpZR4PTyvzeHhamcfDU8p8wMPTyjwenlbm8fC0Mo+Hp5V5D/NKmcfD08o8Hp5W5vHwtDKPh6eVeTw8pcxHPDytzOPhaWUeD08r83h4Wpn3MK+UeTw8rczj4WllHg9PK/N4eFqZx8NTynzCw9PKPB6eVubx8LQyj4enlXkP80qZx8PTyjwenlbm8fC0Mo+Hp5V5PDylzGc8PK3M4+FpZR4PTyvzeHhamfcwr5R5PDytzOPhaWUeD08r83h4WpnHw1PKfMHD08o8Hp5W5vHwtDKPh6eVeQ/zSpnHw9PKPB6eVubx8LQyj4enlXnhHl6O26+Yv4TvNtlGlA1l/20bf/T+VLjG2kPm1t0U46Ktydzl/erit3QXd1WKJb9f7OIWbxen2sXW7fforLf3F79hLtsCWhNz2ebLmpjLtj3WxNyDeX/M3VEROZfzA+ayl/prYi57kT0p5pef2y/21j6/2Ga3V5Y2+9bFxh8Xm5Ae2JS9cIbN311st2OxZV3j4pDcvj78sYC83d4b8bLXzRA/jHjZy2aIH0W8wXCYi/hw4GFT/grxuB5Kicd6mYr428LLujuL/r1UN5g6K7HpYXMhNjGipmLTH2HY4NLzi03IdocjbtsD9fhhaqnHPFuX+mT3i00K5itVOE4bKmmrBFsOlTRVYvHwFlZJOjaMpZ+XGJ9VCYYfKmmrBHfw5SqJByC55fQ2HuRb3MGp2Oz2WM96iNdJPJ7jXMT3eqxncRyVEo/fOBXxz58ZWXzBldjEv1uITYfPNhWbHR/qOcwztdTjiK1LfbdnMA6nDZW0VeJRCSppqgQPb2GV9HpS5zD8UElbJbiDr1ZJ8XsYtqQvrkVwB1diE3dwKja7FXgeI1Ep8diISonHRJyL+F71t8cXVEq8h/gBxGd3EF9aK+6Ob8TyWHJTsdltP6XHZVNKPMaZUuLx2OYivtdGWo8dp5P4gB03FfHPd2kGPLaV2MQ4W4lN3LCp2Oy4jTZ4qNdKPebZutR3e0QWcNpQSVsl2HKopK0SPLyFVdLrEW3A8EMlTZVE3MGXq6TfG7Ei7uBUbHZ7rBcxEpUSj+c4F/G9HutFD/E6icdvnIr458+MIr7gSmzi363EJj7bVGx2fKgXMc+0Up9wxNalvtszmITThkraKsGWQyVtleDhLaySXk/qkkclqKSpEtzBV6uk4zuUEu7gSmziDk7FZr8CDyNRKfHYiDqJz5iIcxHfq/7O+IJKiRdu9cVi9qtTCLMQf3lCu19sf95B/Ya5cONsScw9mH875sJNnSUxF269zIn5bcONczk/YC7cIFkSc+HexJyYf+5DG/3e5JmFGw6w+fPF3c6BFOGGA8SPIl644QDxo4jHcJiL+F4HgAquh1LiPcTPRPzz0yUFU2clNrGLVmITI2oqNjse/yn4YWqpxzxbl/peW3v8htOGStoqwZZDJW2V4OEtrJJOW8v8huGHStoq8ajk1Srp9iZPv+EOTsVmr8d6F9IgXifxeI5zEd/psZ7fcByVEo/fOBXxT58ZeYMvuBKb+HcrsYnPNhWb/R7qeYN5ppZ6D/XLUt/tGYzBaUMlbZVgy6GStkrw8BZWSa8ndQbDD5W0VYI7+GqV9Hv3o7e4gyuxiTs4FZvdCjyLkaiUeGxEpcR7iJ+K+F71t8UXVEo8Vt8I4j/1oY1ub8TyFktuKja77ae0uGxKicc400m8w2Obi/heG2kddpxS4rHjpiL++S5Nh8e2EpseNhdiEzdsKjY7bqN1+GFqqcc8W5f6bo/IHE4bKmmrBFsOlTRV4vHwFlZJr0e0HsMPlbRVgjv4cpX0eyOWxx2cis1uj/W8h3idxOM5zkV8r8d6HsdRKfH4jVMR//yZkccXXIlN/LuF2Az4bFOx2fGhXsA8U0s9jti61Hd7BhNw2lBJWyUelaCSpkrw8BZWSa8ndQHDD5W0VYI7+GqVdHyHUsAdXIlN3MGp2OxW4EWMRKXEYyMqJR4TcS7ie9XfEV9QKfFeNvH5gNAWY38i/i184R5UjvYWvnsMX7Y54jZ7CHhL8TF82av2ZvjfvkyN26HmeKfmH+G/BVSEBZQ2aQEZaQF9e8UU3bH5I4b8GJCTFpCXFtC3zxnFHdVLKf4xoOosEMxt3jblbvRytSom+bJvzU7B3/rItYvdLfr7OTVc/Z6UOoRzKzpSKPZ5ONZux6hu7V2dtPl6SXDQW+LWuNqEEo5iMJR4J4dcar9u7BGL8TcZuK1aabq436bxZvvp6jcoM1D2gPLyt3/725/+/Oc//ee//Pmv//6vf//TX//y3z/abj/+r77f7e7e3BbuVO78D2rqO6VajeyZRu5MI3+mUTjTKJ5plM40ymcalRON4hlFxDOKiGcUEc8oIp5RRDyjiHhGEfGMIuIZRcQzikhnFJHOKCKdUUQ6o4h0RhHpjCLSGUWkM4pIZxSRzigin1FEPqOIfEYR+Ywi8hlF5DOKyGcUkc8oIp9RRD6jiHJGEeWMIsoZRZQziihnFFHOKKKcUUQ5o4hyRhHljCLMtp1qZU61sqdauVOt/KlW4VSrqjBc9DcjPd/WQLludx97krY70y/XHPq87WuU7Erj2pL3BUopP1/7FniaNfA8a+Bl0sDNNmvgZtbA7ayBu1kD97MGHmYNfNaZ08w6cxrBM2c8vNdts4+RC546n0duBc+djcgFT56NyAXPno3IBU+fjch/MX+WY49CNvl55JcnKkfoxt+ekZTq7oeybz3x5m5PYEzXaOqTYrb7k0FXYmpE447Qbdhu6FweBr31EIf3kIb3kIf3UEb3UP90UtcezPAe7PAe3PAe/PAehue0G57TbnhOu+E57YbntB+e0354TvvhOe2H57QfntN+eE774Tnth+e0H57TfnhOh+E5HYbndBie02F4TofhOR2G53QYntNheE6H4Tkdhud0HJ7TcXhOx+E5HYfndBye03F4TsfhOR2H53QcntNxeE6n4Tmdhud0Gp7TaXhOp+E5nYbndBqe02l4TqcOOR3S8V75uPmHHsroHvI2vAczvAc7vAc3vAc/vIcwvIfYtwcTHnrokNN3Bymjdfc9jHy+mvO0kZdZIy/btJGbaSO300bupo3cTxt5mDbyOG3k086hZdo5tMw6h9pt1jnUbpLn0KcbZuwmeRJthC55Fm2ELnkabYQueR5thC55Im2E3mEmjf72xg6ff7fetVse3kMZ3YPpMIPE4/ULyT34cNaY4T3Y4T244T344T2E4T3E4T2k4T3k4T2U0T3Y4Tlth+e0HZ7TdnhO2+E5bYfntB2e0/XdoSYcH/g0cbtNW8lXq4a9wsj+9vsm+GsHcXQHaXQHeXQHZXAH9Y2hPTswX+/guDbfv5Sx+qK1S2V2vEDT3L1v1ddeIXV7V+hPrwqt//Aln/Yf9tvdy6l8uN6nVXKfTsl9eiX32R7l7U/3+dYonmmUTjSqb0FNIeznmlKI5fnSNR3viUvpJ2Dfft9++fdtTMdCLt2td9+n0foG1K49+OE9hOE9xOE9pOE95OE9lNE91DegfrYHe+vBP/Twi3zI29HD/YHM8vnCNfrhPYThPcThPaThPeThPZTRPaRteA9meA92eA/DczoNz+k0PKfT8JxOw3M6Dc/p1CGn0+01xdnYxsUuH2fk3d3Lld8L0LzJCsfICsfKCsfJCsfLCifICifKCid9ezjbLZyHhW/OssIposIp3z0qh9tXPcLdBuv0i4897J9v8FsqD7Eb0bEfn/b022OSFDsL7pXYv3ty8MdXMy42k/vHF0z04ucNPcwbepw39DRv6HnW0J3ZJIf+macR5vZFJHP3gdDq04hLnO/Xuu2nS98gMUDye0gskPweEtFT82sg8UDye0hElxKvgUR0ifIaSESXPq+BRHRJ9RpICpD8DhJL9foACdXrAyRUrw+QUL0+QOKB5PeQUL0+QEL1+gAJ1esDJFSvD5BQvf4eEkf1+gAJ1esDJFSvD5BQvT5A4oHk95BQvT5AQvX6AAnV6+8h8cuoZNQJNVMuN/V+9eXP9na929wVw2Vk9UIMl1lFvRDDZZZdr8MwLLNOeyGGyyzsXojhMivBF2K4zNLxhRh6MPwyhsssTl+IIeuUr2PIOuXrGLJO+TqGrFO+jGFknfJ1DFmnfB1D1ilfx5B1ytcx9GD4ZQxZp3wdQ9YpX8eQdcrXMWSd8nUMWad8GcPEOuXrGLJO+TqGrFO+jiHrlK9j6MHwyxiyTvk6hqxTvo4h65SvY8g65esYsk75MoaZdcrXMWSd8nUMWad8HUPWKV/H0IPhlzFknfJ1DFmnfB1D1ilfx5B1ytcxZJ3yZQwL65SvY8g65esYsk75OoasU76OoQfDL2PIOuXrGLJO+TqGrFO+jiHrlK9jyDrlqxj6jXXK1zFknfJ1DFmnfB1D1ilfx9CD4ZcxZJ3ydQxZp3wdQ9YpX8dwnXVKKjcM03MMn72Kz2/rLDt6QbLOF+v6QfJKlbjtOSQp7mNESvH3kb/0Ay5fi9xMG3mH5U/2R+TlTrrVi50t+xconbsb9k1M13icsHi8sHiCsHiisHiSsHiysHiKrHh6fPagazxGWDzCxmc3dHx+68EP7yEM76HDqFjivkByxjfqgbz5vdJ05bjU5ly5tuSd4FJ+vvYt8jRt5HnayMuskftt2sjNtJHbaSN300bup408TBv5tHOon3YO9dPOoX7aObTHi4uL9Uc16s3vq9Eer/Vt9JCH91BG99DjhamNHszwHuzwHtzwHvzwHsLwHobndBye03F4TsfhOZ2G53QantNpeE6n4Tmdhud0Gp7TaXhOp+E5nYbndBqe03l4TufhOZ2H53QentN5eE7n4Tmdh+d0Hp7TeXhO5+E5XYbndBme02V4TpfhOV2G53QZntNleE6X4Tldhud0GZ3TYduG92CG92CH9+CG9+CH9xCG9xCH95CG95CH9zA8p83wnDbDc9oMz2kzPKfN8Jw2w3PaDM9pMzynzfCcNsNz2g7PaTs8p+3wnLbDc9oOz2k7PKft8Jy2w3PaDs9pOzyn3fCcdsNz2g3PaTc8p93wnHbDc9oNz2k3PKfd8Jx2w3PaD89pPzyn/fCc9sNz2g/PaT88p/3wnPbDc9oPz2k/PKfD8JwOw3M6DM/pMDynw/CcDsNzevg+sjB8H1kYvo8sDN9HFobvIwvD95GF4fvIwvB9ZGH4PrIwfB9ZGL6PLETJe5Xjfq3ZNvvTxW+hS96s3Ahd8m7l56EnyUd+GqFLPvPTCF3yoZ9G6ENP/bz18PWR3pm4HT38eIvC73oIw3uIw3tIw3vIo3vosPev1YMZ3oMd3oMb3sPwjMvDMy4Pz7g8POPy+Iwro3sow3O6DM/pMjyny/CcLsNzugzP6TI8p8vwnC7Dc7qMzum4bcN7MMN7sMN7cMN78MN7CMN7iMN7SMN7yMN7GJ7TZnhOm+E5bYbntBme02Z4TpvhOW2G57QZntNmeE6b4Tlth+e0HZ7TdnhO2+E5bYfntB2e03Z4TtvhOW2H57QdntNueE674Tnthue0G57TbnhOu+E57YbntBue0254TrvhOe2H57QfntN+eE774Tnth+e0H57TfnhO++E57YfntB+e02F4TofhOR2G53QYntNheE6H4Tkdhud0GJ7TYXhOh+E5HYfndBye03F4TsfhOR2H53QcntNxeE7H4Tkdh+d0HJ7TaXhOp+E5nYbndBqe08N3ecXhu7zi8F1ecfgurzh8l1dMw3N6+D6yOHwfWRy+jywO30cWe+wjC9v+4TQXc3h+cbe3Nsce+9NeFHmcNvIkOPKnm6Bjj416rwq9TBt6j62FrwrdzBu6nTf0DjNeMvvnFl2y5fnFzz7NGHtsyOwXTJAUTBwZzFsPaXgPeXgPXx+4/Rb2L836LW2NcGzJezjO3Gq9N85Shy2hPaMxoqKx3xyNi8fw6nK6i6byw+aI3FuTfh+5mzZy3zVyY39/LC112Brb6iEO7+Hr46CP9qDhMgo8v9j4dEzQwdy+r21K7eq47b8cbby7Nl9jzxPHXuaNvcNG4dfFbiaO3U4cu5s4dj9x7GHi2OPEsU88r5qJ51Uz8bxqJ55X7cTzqp14XrUTz6tW9vju94tjMI+xyx5njtepxJgfYnffPc4EE47Ynf8p9rd4jLB4rLB4nLB4/Hdr35tbPKGhfRNTTPvlMeXtd76QC1NHH6eOPk0dfZ46+qEz1o8e/Da8BzO8hw5jfwr7UxtfNte4uOycBXM/0obKtfbyHOH9YpvurNwrvx0Ox7wqcj9t5GHayOO0kadpI8/TRl5mjbzDIaxXRW6mjXzaOTRMO4d2OOT2qsinnUODmDn0LRox8+JbNGLmurdoxMxfP6KJYuakt2jEzDNv0YiZO96iETMfvEUjZox/i+abx+1gdzMk+NwYt82W3f7Llz+H33shMU4ce5o49jxv7MlIjr0cu/wuf47m97F70bEfYRizbfH3sYseZxqxix5nGrF/9zgTjtkm+2bsqYRbrpqH2PPEsZd5Y8/bxLEbybE/n5uynTh2N3HsfuLYRY/vz+uZInqceT6vFtHjTCN20eNMI/ah48xbD354D2F4D3F4D2l4Dx2qv+L3WiE439qncXnisQsvxXK7OH/aUu5xpPM1oece5z9fFbqZN3Q7b+hu3tD9vKGHeUOP84ae5g192tk0b/POpmbe2dTMO5uaeWdTM+9s2uN87atCn3c2NfPOpmbe2dTImU3fwpEzQ/4Ix8qZ9d7CkTOTvYUjZ3Z6C0fOjPMWjpxZ5C0cOTPDWzhyRvu3cOSM4G/hyBqVraxR2ckalZ2sUdnJGpWdrFHZyRqVnaxR2ckalZ2sUdnJGpWdrFHZyxqVvaxR2csalb2sUdnLGpW9rFHZyxqVvaxR2csalb2sUTnIGpWDrFE5yBqVg6xROcgalYOsUTnIGpWDrFE5yBqVg6xROcoalaOsUTnKGpWjrFE5yhqVo6xROcoalaOsUTnKGpWjrFE5yRqVk6xROckalZOsUTnJGpWTrFE5yRqVk6xROckalZOsUTnLGpWzrFE5yxqVs6xROcsalbOsUTnLGpWzrFE5yxqVs6xRucgalYusUbnIGpWLrFG5yBqVi6xRucgalYusUVnQWdq3cESNykXQmde3cESNykXQ2dS3cESNymUTNSoXQedC38IRNSoXQec338IRNSoXQecsf4Qj6OzkWziyRmVBZxzfwpE1Kgs6i/gWjqxRWdCZwbdwZI3Kss72FVln+4qss31F1tm+IutsX5F1tq/IOttXZJ3tK7LO9hVZZ/uKrLN9RdbZviLrbF+RdbavyDrbV2Sd7SuyzvYVWWf7iqyzfUXW2b4i62xfkXW2r8g621dkne0rss72FVln+4qss31F1tm+IutsX5F1tq/IOttXZJ3tK7LO9hVZZ/uKrLN9RdbZviLrbF+RdbavyDrbV2Sd7SuyzvYVWWf7iqyzfUXW2b4i62xfkXW2r8g621dkne0rss72FVln+4qss31F1tm+IutsX5F1tq/IOttXZJ3tK7LO9hVZZ/uKrLN9RdbZviLrbF+RdbavyDrbV2Sd7SuyzvYVWWf7iqyzfUXW2b4i62xfkXW2r8g621dkne0rss72FVln+4qss31F1tm+IutsX5F1tq/IOttXZJ3tK7LO9hVZZ/vMJutw3yUeUePyJR5RA/MlHlEj8yUeUUPzJR5RY/OPLzR/czxl23/ZFFeJ59tH5xSPeMp2H8/jxXnz79fmu9Bt9drLYuT92suY+tO11/vMSu6z6LjP7z/u+KL7NEru0yq5T6fkPr2S+wxK7jMquU8l9ZBRUg8ZJfWQVVIPWSX1kFVSD1kl9dD3H+Z+0X0uUw/F/dofpl/lRpcpiFo3ukxF1LrRZUqi1o0uUxM1btQtUxS1blROVXSNR071co1HTpVxjccLi0fOrH2NR87keo1Hzhx4jUfOVHWNR86M8haPlzPwX+MRNj57YePzd79NwJpU3i/2qYTnE7V3eb82+uNSU1Lth2+PW50xjQogbscvxy2520879w6LVwlL8Hu1E0PaKrAEYKnBEoGlBksClhosGVhqsBRgqcDy3W8BmQUWAyw1WCyw1GDRWeU2YfHAUoOFKrcKC1VuFRaq3CosVLlVWKhya7BEqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaq3CosVLlVWKhya7AkqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaq3CosVLlVWKhya7BkqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaq3CosVLlVWKhya7AUqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaq3CosVLlVWKhyK7CYjSq3CgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3Boshiq3CgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3Bosliq3CgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3Bosjiq3CgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3Bosniq3CgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3BosfPusDgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3BosfPusDgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3BosfPusDgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3BosfPusDgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3BosfPusDgtVbhUWqtwqLFS5VVg8sNRgocqtwkKVW4WFKrcKC1VuFRaq3Aoslm+f1WGhyq3CQpVbhYUqtwqLB5YaLFS5VViocquwUOVWYaHKrcJClVuDhW+f1WGhyq3CQpVbhYUqtwqLB5YaLFS5VViocquwUOVWYaHKrcJClVuDhW+f1WGhyq3CQpVbhYUqtwqLB5YaLFS5VViocquwUOVWYaHKrcJClVuDhW+f1WGhyq3CQpVbhYUqtwqLB5YaLFS5VViocquwUOVWYaHKrcJClVuDhW+f1WGhyq3CQpVbhYUqtwqLB5YaLFS5VViocquwUOVWYaHKrcJClVuDRem3z1JyOyzZ5p9gqV1tjovjXRj5HUKdFXFXCHVWz10h1Flpd4XQA+FXIdRZwXeFUGW1n0KK+/1FvzUgdM7uv+xvERtbuTTEsP/wpQC6u9jXYy7HL29b/unqKzsqFx3TsKNy7TMNOyqXYLOwo/P7gNOwo3KROQ07Ktev07Cjcmk8DTsedgSzo3JBPw07eAWS2cErkMwOXoFkdvAKBLOj8yur07CDVyCZHbwCyezgFUhmx8OOYHbwCiSzg1cgmR28Asns4BVIZgevQDA7Or9VPQ07eAWS2cErkMwOXoFkdjzsCGYHr0AyO3gFktnBK5DMDl6BZHbwCgSzU/AKJLODVyCZHbwCyezgFUhmx8OOYHbwCiSzg1cgmR28Asns4BVIZgevQC47l3+EHcHs4BVIZgevQDI7eAWS2fGwI5gdvALJ7OAVSGYHr0AyO3gFktnBKxDMjsErkMwOXoFkdvAKJLODVyCZHQ87gtnBK5DMDl6BZHbwCiSzg1cgmR28AsHsWLwCyezgFUhmB69AMjt4BZLZ8bAjmB28Asns4BVIZgevQDI7eAWS2cErEMyOwyuQzA5egWR28Aoks4NXIJkdDzuC2cErkMwOXoFkdvAKJLODVyCZHbwCwex4vALJ7OAVSGYHr0AyO3gFktnxsCOYHbwCyezgFUhmB69AMjt4BZLZwSsQzE7AK5DMDl6BZHbwCiSzg1cgmR0PO4LZwSuQzA5egWR28Aoks4NXIJkdvALB7ES8Asns4BVIZgevQDI7eAWS2fGwI5gdvALJ7OAVSGYHr0AyO3gFktnBKxDMTsIrkMwOXoFkdvAKJLODVyCZHQ87gtnBK5DMDl6BZHbwCiSzg1cgmR28AsHsZLwCyezgFUhmB69AMjt4BZLZ8bAjmB28Asns4BVIZgevQDI7eAWS2cErEMxOwSuQzA5egWR28Aoks4NXIJkdDzuC2cErkMwOXoFkdvAKJLODVyCZHbwCuez4Da9AMjt4BZLZwSuQzA5egWR2POwIZgevQDI7eAWS2cErkMwOXoFkdvAKBLNj8Aoks4NXIJkdvALJ7OAVSGbHa2QnlLKHnHJwLXayN/tP53gDMdYuNt7uP30BOd6RaWo/bdIt6jugbapevbkjEBPScfXlL5Wrs4l7JNlu5fbbdRbT5g5ifihv/+1o3pWi0rdAKSeUotJDQSknlKLSz0EpJ5Si0ltCKSeUotLnQimfV4pV6bmhlBNKUen/oZQTSlHpRaKUE0pR6YuilBNK8SgFpXxIKXi0KOVjSsGjRSkfUwoeLUr5mFLwaFHKx5SCR/tSpfhth8P5ZBtK8c7se0i8+3HF/tvxSqbDRl2ITJzOhcjEjFyITPzChcj0kLkOmbhuC5GJMbYQmXhXC5GJvbQQmThA65DpcYAWIlOBA3S9UQXuyPVGFTgH1xv1Wm5UwYrzeqMKVmPXG1WwUrneqIIq/nqjCirctxsNCqq/641qqYyClsooaKmMgtdyo1oqo6ClMgpaKqOgpTIKWiqjqKUyiloqo6ilMopaKqPotdyolsooaqmMopbKKGqpjKKWyihpqYySlsooaamMkpbKKHktN6qlMkpaKqOkpTJKWiqjpKUyyloqo6ylMspaKqOspTLKXsuNaqmMspbKKGupjLKWyihrqYyKlsqoaKmMipbKqGipjIrXcqNaKqOipTIqWiqjoqUyKkoqo7ApqYzCpqQyCpuSyihsSiqjsHktN6qkMgoaPhV/vVEllVHQ8AHz641qqYw0fFb7eqNaKiMNH3u+3qiWykjDJ4ivN6qlMtLwAdjrjWqpjDR8fvN6o1oqIw0fP7zeqJbKSMOn5643qqUy0vDhr+uNaqmMNHx26XqjWiojDR+9ud6olspIw/dMrjeqpTLS8B2M641qqYw0fD/heqNaKiMN792/3qiWykjD+9qvN6qlMtLwnu/rjWqpjLS8AztoeQd20PIO7KDlHdhByzuwg5Z3YAct78AOWt6BHbS8AztoeQd20PIO7KDlHdhByzuwg5Z3YAct78AOWt6BHbS8AztoeQd20PIO7KDlHdhB9psezXGjNv10o9fY5UyN13jkzGDXeORMNNd45MwH13jkDNtv8Qh6W9w1HjmD4DUeOWPVNR45i61rPF5YPMLGZ0HvBbvGI2x8FvSWrWs8wsZnQe+susYjbHwW9AaoazzCxmdB71O6xiNsfBb0dqJrPMLGZ0Hv+rnGI2t8joLenHONR9b4HAW9h+Yaj6zxOW6yxuco6OUr13hkjc9R0KtMrvHIGp+joBeDvMUj6P0d13iEjc+C3oZxjUfY+Czo3RLXeISNz4Le1HCNR9j4LOi9B9d4hI3Pgt4icI1H2Pgs6Ez+NR5h47OgE+7XeISNz4LOi1/jETY+Czp9fY1H2Pgs6CzzNR5h47Ogk8HXeISNz4LO2V7jETY+Czq1eo1H2Pgs6AzoNR5h47OgE5XXeISNz4LOJ17jETY+Czrtd43nm8dnn5Pd4ymbe4wnfnc82y0eY+7jebw4b/792uzKcamtXltyfL+2lJ+vvd5nUnKfWcl9Fh33+d3n5l52n0bJfVol9+mU3KdXcp9ByX0qqYeCknooKKmHgpJ6KC5TD8X9WrNttnKjyxRErRtdpiJq3egyJVHrRr2WG12mKGrd6NCq6NpFGt9FHt9FGd5F2sZ3YcZ3Ycd34cZ34cd3EcZ3MT670/jsTuOzO43P7jw+u/P47M7jszuPz+48Prvz+OzO47M7j8/uPD678/jsLuOzu4zP7jI+u8v47C7js7uMz+4yPrvL+Owu47O7DM/utG3juzDju7Dju3Dju/Djuwjju4jju0jju8jjuxif3WZ8dpvx2W3GZ7cZn91mfHab8dltxme3GZ/dZnx2m/HZbcdntx2f3XZ8dtvx2W3HZ7cdn912fHbb8dltx2e3HZ/dbnx2u/HZ7cZntxuf3W58drvx2e3GZ7cbn91ufHa78dntx2e3H5/dfnx2+/HZ7cdntx+f3X58dvvx2e3HZ7cfn91hfHaH8dkdxmd3GJ/dYXx2h/HZHcZndxif3WF8dofx2R3HZ3ccn91xfHbH8dkdx2d3HJ/d4/eqpfF71dL4vWpp/F61NH6vWhq/Vy2N36uWxu9VSx32qgUX9sPNIcTy/OJ+m/5Thz1wLws9zht6mjf0PG/oZdrQO+xdfFnoZt7Q7byhu3lDn3c2zfPOpnne2TTPO5vmeWfTPO9sWiTPps/Pi6UieTptxS55Pm3FLnlCbcUueUZtxS55Sm3FPnROvXaRxneRx3dRRneRt218F2Z8F3Z8F258F358F2F8F3F8F2l8F8OzO3fYex1C3r+tHKMzzy9+/h3m3GGH85Nwrl2E8V3E8V2k8V18XX1pc2a/eAuN2d0mk94vtsne3iGa/Hs8RVY8HfZO943HCIvHCovHCYvHC4snCIsnfnc83h/xxPgYTxIWTxYWzzePz87E/WJ3WaY8xOM2YfEYYfFYYfG4744n2KfxfPP441x0ezwu2cd4krB4srB4iqx4/HePPy5sRzzxp3gq67DtSEa/VcTvjejg8/FCuK08zkTezoJ8LfjvHgZdOYZlf/ephHOy8aKDb8gmzIJ8Lfjvnq28zUfwYXuMJwmLJwuLp8iKJ2yvjMc/xmOExWOFxeOExfPdI789vjjkfCzPB88fLxh8v/jHicPjYhP26L979EzuqB2TD1+bdEMSHfzzSTfkWZCvBf/dg3gst+B/tmAqot+Oi41x26Po43cP+SntW39c/nkKqkG/m4Pe/pywlTt1ZR+bjL97QfRloHq/U6PmTq2aO3Vq7tSrudOg5k6jmjtNU97pNfY8cexl3tiT6MrE7VH4lCuxi641GrH/Yk4tew8pmnwfzrWVP9UqnGoVT7VKp1rlU63KmVa/OkTWaGVOtbKnWp3SRj6ljXxKG/mUNvIpbfQ4ptBx31yRtY2vx2GCnuE4WeF4WeEEWeHEbw7HH1Ni+DmcWujlFru5XR3fQ0/zhp7nDb3MGnrZtnlDN/OGbucN3c0bup839DBv6NPOpmWbdjYt27SzadnmnU3NvLOpmXc2NfPOpmbe2XTsQbmxoc87m5p5Z1Mz72xq5p1Nzbyzqf3u2dQd0UTfCL21n6tYM3Pwdubg3czB+5mDDzMHH+UGH8oxUMaw5ec//OMc9vvFdttu+wtNTO93mtTcaZ7yTq+xl3ljd2Jm7ms4Q1/y/HjxpZbZd4b7VG66rL4m6vnDqDL2q02DYw8Txx4njj1NHHueOPYyb+xjv+X11dj7LSrHflBM0H1aJfcpem7veJ9eyX2Krhk63qfo+qLjfYquRT6x5mm8zrV40YVLzxsVXeV0vNEguiTqeaOia6KeNyq6KOp5o6Krop436rXcqOi6qOeNii6Met6olsooaKmMgpbKKGqpjKKWyihqqYyilspo7EeFJd2olsooaqmMopbKKGqpjKKWyihpqYySlsooaamMkpbKqMMH2Se5US2VUdJSGSUtlVHSUhklLZVRXqUyssHvP2xDyc9/+IefvcNSsrmD5X2rbF6ljvocLPl4M6zd3M+wPF6dTdxvMNutNK72+fZqt8vlx9UumnfIV6noJoJ8ldpyIsg9kH835KvU2xNBvkrlPxHkq6xBJoJ8ldXQRJCvsi6bB/Kic4X4UshZfX475Kw+vwT5FUTWkx1A9ID4dRBZ87VBtOYGYrCNq9MNjnRJ9MbV7vBX/d1oa30VunJ8Ptwae3/xlUrWkstQyRp1GSpZ+y5DJWvqNai028ZafRkq8QCWoRJvYRkqcTiWodJD5SpU4vYsQyVuzzJU4vYsQyVuzzJU4vasQqXB7VmGStyeZajE7VmGStyeZaj0ULkKlbg9y1CJ27MMlbg9y1CJ27MMlbg9q1BpcXuWoRK3ZxkqcXuWoZJ15TRUWnej0odHKqlgp6EymeMOk3OPVFLBrkKlo4Jdhkoq2GWopIJdhkqeVy5DpYfKVahkXbkMlTyvXIZKnleuQqXsj3B/hsqy7SE7Y7bnPxyD3z2wGNLtYnNB6ArLMvNOX1iWGcP7wrLMeNgXlmWc5L6wLOPKdoVlmW+Td4ZlGbewLyzLOG99YVnGxeoLiweWGixUuVVYqHKrsFDlVmGhyq3CQpVbg2WZ78x3hoUqtwoLVW4VFqrcKiweWGqwUOVWYaHKrcJClVuFhSq3CgtVbg2WpLLKDaXsIcdiarCorHLbsKisctuwqKxy27B4YKnBorLKbcOissptw6Kyym3DorLKbcOissptwpJVVrkppH33YYr+Z1ger3bO7r98d9b0xwniR7zjsa3xsqi4u9jXYy7HL29b/unqKzsqR34h7Lit7GA4a1pXpz2KlI4rDxpVzlTr0ahyZl2PRpWVwHI0rvNdct00qvQT16NRpf+5Ho0q/dr1aPTQuAKNKv3w9WjExVmCRlycJWjExVmCRlycBWg063yxXjeNuDhL0IiLswSNuDhL0OihcQUacXGWoFHngsPZ4/6Sdw0azYWQ96tNiuV2ddhqTG77u+jCvUAu174Bvs7njWcBXGcR/0LAdZbbLwRcZ2H8QsA9gH8v4DqLzRcCrvPh3gsB1/kY7oWA63xg9kLAWWn2BjzuZ/3v35Bev9bbsLPjbfY/OQZv9FgPPX3pycfFObnGtdbZ/WLrffMN9ibe3mC/lcbVPm9pRy/fvZXeRfNOPdWVWuqp89RST8WplnpqX7XUU4VrpX6dD9VC/Wep5xmYWup5GqeWep4LqqXeQ71W6nHzlqD+Sib+3EJk4rgtRCYe2jxkCvnisyn7A1trjb2/+CopvDkk1VdSHs8PSXWWFF4ikuosKTxKJNVZUnifSKqzpDySQlJ9JYVXi6Q6SwrHGEl1lhS+NZLqLCnccyTVWVK450iqr6QC7jmS6iwp3HMk1VlSuOdIqrOkcM+RVGdJeSSFpPpKCvccSXWWFO45kuosKdxzJNVZUrjnSKqzpHDPkVRfSUXccyTVWVK450iqs6Rwz5FUZ0nhniOpzpLySApJ9ZUU7jmS6iwpfCkk9UlJWXeT1N1H8nZJJVZ8SOqTkkpmp9Am5x4lxYoPSXWWFCs+JNVZUh5JIam+kmLFh6Q6S4r9Ukiqs6TYL4WkOksKXwpJdZYU+6WQVF9JZfZLIanOksI97yypYs37xSWExrVhS8cHes12F8f+zd2MEy2aHlxd0fR46JFMD25j73Im759wN9sWW/XM7QMWl2fsqVXP9P0GUcYW1Ms9/p1e7jHa9HKPI6aW+4J1pZd7PCa93GNg6eUed0wv9x7u1XKPr6eXe3y9Nbi/solTtxKbeG8rsYmbNhGbUxzPthsuHZrqrSncPzTVW1O4imiqt6ZwK9FUb015NIWmOmsKdxVN9dYUri2a6q0pvGM01VtTONhoqrem8NHRVGdNGXx0NNVbU/joaKq3pvDR0VRvTeGjo6nemvJoCk111hQ+OprqrSl8dDTVW1P46Giqt6bw0dFUb03ho6Opzpqy+Ohoqrem8NHRVG9N4aOjqd6awkdHU7015dEUmuqsKXx0NNVbU/joaKq3pvCn0NRnNfX82+PWse5DU5/V1PMv8ljHug9N9daUR1NoqrOmWPehqd6aYt2Hpnpriv1TaKq3ptg/haZ6awp/Ck111pRn/xSa6q0p9k+hqd6a8miqqalo/aGp1JRJ2Y4nFyW4xtV+23YJ+s3f6fX9U73WU5x0Jsht2/4pZbflJp3OHlnvvWllfddvethAFaGYfKZ7xeTzfFsx+TyIVky+h3y95PNoVzH5PINVTD4PSxWTz1NNxeTj8OklP+LwLUL+lU48u6XoxIVbik58tZnonON0Y/SIClH1FhU+IKLqLir8RUTVXVT4loiqu6jwQxFVd1HhsyKq3qJK+LeIqruocJERVXdR4WUjqu6iwlFHVN1F5REVouotKhx1RNVdVDjqiKq7qHDUEVV3UeGoI6ruosJRR1S9RZVx1BFVd1HhqCOq7qLCUUdU3UWFo46ouovKIypE1VtUOOqIqruocNQRVXdR4agjqu6iwlFHVN1FhaOOqHqLquCoI6ruosKnQlSfFlXjq76F1R+i+rSoGp+4KKz+EFV3UbH6Q1TdRcXqD1F1FtUFAUSFqHqLiv1UiKq7qNhPhai6iwqfClF1F5VHVIiqt6jYT4WouosKR723qMyWj0BCalx9AeHgMt+Bt3/f122408IJwukVThCuqWyCDA5kd4LSQZC1LYLs7bsYlwfwqVXYdP3A0QUnyNdLPo6eYvJx3hST7yFfL/k4WYrJx3FSTD5ulmLyccoUk48Lp5d8i8OnmHwcvkXIv9KJZ7cUnbhwS9HpoXMiOqc4y+0sfh2i6i4qfEBE1V1U+IuIqruo8C0RVXdR4Yciqt6icvisiKq7qPBvEVV3UeEiI6ruosLLRlTdReURFaLqLSocdUTVXVQ46oiqu6hw1BFVd1HhqCOq7qLCUUdUvUXlcdQRVXdR4agjqu6iwlFHVN1FhaOOqLqLyiMqRNVbVDjqiKq7qHDUEVV3UeGoI6ruosJRR1TdRYWjjqh6iyrgqCOq7qLCUUdU3UXlERWi+qyonn/C3AVWf4jq06JqfMUnsPpDVN1FxeoPUfUWVWT1h6i6i4rVH6LqLir2UyGq7qJiPxWi6i4qj6gQVW9RsZ8KUXUXFfupEFV3Uan0qUIpB9w5tETlsj++dJ9jPq6OVQU6t3/Rwbh8+9C9saZ6h7tcfb6BYeI7O0ml4TMNOyqdk2nYUWlBTMOOyrX8NOx42BHMjsrVpRh2wlF9h1hjR+UybRp2VO4gksNO2oMOqVTYUbkVZxp28Apeys6x4TZu7pGdjFcgmR28AiHsGFNhB69AMjt4Ba9kJ6b9l2PeKux42BHMDl7BS9nJexyx+Ao7eAWS2cEreCU7advRSCZX2MErkMwOXoEQdmx8ZKfgFUhmB69AMjt4BS9l54gjb5WareAVSGbHw84L2cnHyJZrNVvBK5DMDl7BS9lxbmfH2wo7eAWS2cErEMJOqHjUBa9ALjt+wyt4JTvF7BeXymrUb3gFktnBK3gpO27/5eJNhR28AsnseNh5JTvHPuoSayMbXoFkdvAKhLCTfIUdvALJ7OAVvJIds4U9arPF2noUt0A0Pwa/oDM/3u4/bfz9O02q/DiTblHfAW1T9eot7Vuv3ZZvgTgTalcns1tFLt15RT+uvnKPG6GXe7wOvdzjpOjl3sO9Wu5xgfRyj8ekl3scLL3c44/p5R7vTS33Fl9PL/f4enq5x9fTyz2+nl7uPdyr5R5fTy/3+Hp6ucfX08s9vp5e7vH11HLv8PX0co+vp5d7fD293OPr6eXew71a7vH19HKPr6eXe3w9vdzj6+nlHl9vJu6PF6JcCEwN7vPta/TZbrevtdW/GO/T5g5izO0NeS6aq1I8LiBK+ZhS8AxRyseUgsOIUj6mFPxIlPIxpXiUglI+pBQ8D5RyVcoByeWP8VEpgbUPSnnDOm/7m7D85fKKUlj7aFTKlXtWM3q5Z32il3sP96tyb82N+2Ab1UG6sZhKcY2r3fGWWX9XSVhfZbzsD32svVvK2Pc3agZ2baDA1yqQvSMo8LUKxM1Bga9VIPtoUOBrFchuHhT4UgVGnHIU+FoF4sCjwNcqkOcAKPC1CuRpBAp8rQI9CkSBL1Ugz0RQ4GsVyDMRFPhaBfJMBAW+VoE8E0GBr1Ugz0RQ4EsVmHgmggJfq0CeiaDA1yqQZyIo8LUK5JkICnytAj0KRIEvVSDPRFDgaxXIMxEU+FoF8kwEBb5WgTwTQYGvVSDPRFDgSxWYeSaCAl+rQJ6JoMDXKtCjQBQ4VIHW3RTow6MCWQujwLEKTGZn3CbnHhXIWhgFvlaBrIVR4EsVWFgLo8DXKpC1MAp8rQLZH4gCX6tA9geiwNcq0KNAFPhSBbI/EAW+VoHsD0SBr1Ugz0ReqsALHvtPu5QbCuz89abC0wi93PMcQCv3YcOB18s93rde7nGd9XKP36uXew/3arnH49TLPe6iXu7x9fRyj6+3BvdXNnHqFmLT4L2txCZu2kRsTnFOMhhcOjTVW1O4f2iqt6Y8mkJTnTWFW4mmemsKFxRN9dYU7iqa6q0pXFs01VtTeMdoqrOmLA42muqtKXx0NNVbU/joaKq3pvDR0VRvTXk0haY6awofHU311hQ+OprqrSl8dDTVW1P46Giqt6bw0dFUZ005fHQ01VtT+Ohoqrem8NHRVG9N4aOjqd6a8mgKTXXWFD46muqtKXx0NNVbU/joaKq3pvDR0VRnTXn8KTT1WU09/6pv8B5NoalPaur5VxGCZ92HpnprinUfmuqtKdZ9aKq3plj3oanemmL/FJrqrKnA/ik01VtT+FNoqrem2D+Fpnpriv1TaKq3pjyaeqWmvD005X/o6KmmrPcHmT7fvkVsYi2QEnZALojdwZfemcft1so8nrRW5nGOtTKPv6uVeVxYpcxHvFKtzONoamUe3/G1zG/lxrxtMO+dsTsg7k4nF+avZGL4LUSmh8x1yMQ8W4hM/LCFyMTiWohMXKuFyMSIWofMhLe0EJnYRQuRiQO0EJk4QAuR6SFzHjL9jczL/+7JrPx0iofhn417ZB67SCvzeEtamceI0so8rpVW5rG4lDKf8cO0Mo95ppV5nDatzGPLaWXew/yizGfvjqhDemQeD08r83h4yzIf7RH1fSA783h4WpnHw1uW+XJEXbbwyDwenlLmCx6eBuYrq7qCh6eVeTw8rczj4clhPjaYN5s/jj1vP2+tq9zj7Xs0wRr/yLyH+UWZtz4ezMfHVV3Bw1uW+XIw79yjh1fw8LQyj4e3KvMu7RcHf/fduYN5PLxVmfdpRy+ErTLP4+Ety3yMN+YfRvu44eGtynxMe9QhmcbiP0W3yyTF7B5lguGHTD4gE9xBZPIBmWAlIpMPyMQjE2TSlgkmJTL5gExwNJHJD22UfcN6SsY8ygT7E5l8QCZ4pcjkhzaOqFNy5VEmGKvIpC0TgwurTyZX5jFWtTKPV6qVeexPrcx7mFfKPCalVubxHbUyj5WolXncQa3MY/itynw2B/M52Ibh13gYaTH8kMkHZII7iEw+IBOsRGTyAZngOyKTD8jEIxNk0pYJjiYyaW+UstifyOQDMsErRSbtjVIWYxWZfEAmuLA6314SHcYqA0S73HAYq8jkAzLBWEUmH5AJxioy+YBMPDJBJm2ZYKwik/Ya12GsIpMPyARjFZl8QCYYqzrf7h4dXqm+AeKNeY9XqpV57E+tzHuYV8o8toJW5nEKlDIfqPC0Mk+Fp5V5nllrZd7DvFLmqe21Mk9tvyjz0dh9p2s08XGna+DB3rLMb/7GfH5knmd1WpnnWZ1S5iNOzqrMX6DembchPjKPk7Nszh/3eGH+scKLODlamedAgVbmPcwrZR4PrzfzW/4V81fE8c6+G3E8q+9GHK+ojXjZ9hWYK9Y1EDfHDGGMvUXtTKjdod1/2fvb/OC22rXuWAc6b3+69sok3s8iTCa8nFWYxJtZhUm8llWYxDtZhUkPk4swibexCpN4JqswiRezCpN4PKswicfzUiaNPZj0DSbTDedUyi0MWwXahX0vp7c3NH4EVOHkeF+DtcbeX/ymkYx7hEZaGsGXQiMtjeB4oZGWRvDS0EhLIx6NoJGGRvD/0EhLIziLaKSlETxLNNLSCG4oGmlpBJ8VjTQ0UvBZ0UhLI/isaKSlEXxWNNLSCD4rGmlpxKMRNNLQCD4rGmlpBJ8VjbQ0gs+KRloawWdFIy2N4LOikecaSRs+KxppaQSfFY20NILPikZaGsFnRSMtjXg0gkYaGsFnRSMtjeCzopGWRvBH0Ih1N4348KARw7oGjSSzh2yTc48aYV2DRloa8WgEjTQ0wroGjbQ0wroGjbQ0wv4RNNLSCPtH0EhLI/gjaKShEcv+ETTS0gj7R9BISyP4rB/QiM+HRlJ6rhEXjpjN3Q9Xv7uWjvu7h8JUfzdsO+ch2p+uvfKIF7oGjx4el+ART3ENHvH91uARb24NHvHP1uARj2sJHh0+1Bo84hVNwmPcr41baVxrtgNks+XbR5VtfHd/HO6PRtbxij7Aej6+b2RMg/Vs4v7T2d7xU3dvfT4sZ5/v/FsXzTs/Hn5E84O3I5sfPBvZ/ODFyOYHj0U2P3gnovnxeCKy+cHrkM0ProRsfvAPZPPj4efb+LkijiPw3Yizxv9uxFm1d0bcmhviwTZG/Ze9rcPjBujkHZdBJe8B90In77giOnnHbdHJOy6OTt49vKvkHY9KJ+84ZTp5x6/TyTt+nU7e8etU8h7x63Tyjl+nk3f8Op2849fp5N3Du0re8et08o5fp5N3/DqdvOPX6eQdv04l7wm/Tifv+HU6ecev08k7fp1O3j28q+Sd9fuavDe+VJyp59fkvfHllEw9r5N36nmdvFPP6+Tdw7tK3nn+rpN3nr/r5J31u07eef6uk3eev6vkvfj1eb/eqIIC9nqjS1Zszj//YZMPX9pkf/vMi4/vqCxZz3wZlSVn+y+jsuRc+EVU8rbkk50vo7Lkc48vo7LkU4Evo7KkZ/5lVDyoVFBZslz9MirUtjVUqG1rqFDb1lChtq2gYqhta6hQ29ZQobatoUJtW0PFg0oFFWrbGirUtjVUVqltnXV7FM62ftg6u19svTfHxfXHQX0/mJXNKoXzRJCvUpXPA7ldpeSfCPJV1hMTQb7KYmUiyFdZCU0EuQfy74Z8lTXcRJCvskCcCHJWn98OOavPL0F+BZH15NdBdKwQO4DImq8N4hSv9MiOteQyVLJGXYZKD5WrUMmaehkqWasvQyUewDJU4i0sQyUOxypUenyWZajE7VmGStyeZajE7VmGSg+Vq1CJ27MMlbg9y1CJ27MMlbg9y1CJ27MKlQG3ZxkqcXuWoRK3ZxkqcXuWodJD5SpU4vYsQyVuzzJU4vYsQyVuzypURtaV01D5/HOgOXqonIXK51+KyJEKdhkqqWCXoZIKdhkqqWCXoZLnlatQmXheuQyVrCuXoZLnlctQyfPKZaj0q1DpnN2pdMU0qLy9A+dih6UWlX1fl5WWcWXmgXwZ92QeyJdxOeaBfBk3Yh7Il3ENpoE8L7O6nwfyZVbh80C+zGp5HsiXWdXOA7kH8u+GnNXnlyC/gsh6sgOIrBA7gMiarw3iHHsoM2vJVagsrFGXoZK17zJUsqZehkrW6stQ6aFyFSrxFpahEodjGSrxWZahErdnGSpxexahsmy4PctQiduzDJW4PctQiduzDJUeKlehErdnGSpxe5ahErdnGSpxe5ahErdnFSoNbs8yVOL2LEMlbs8yVOL2LEOlh8pVqMTtWYZK1pXTUPn8Zc3FUsFOQ+XzNzEVSwW7DJVUsMtQ6aFyFSqpYJehkueVy1DJ88plqGRduQyVPK9chUrH88plqFzG7fHb/sPOB3//w9cb9VpudJk1SetGV6nYvUn7KOTNXfLXf/jXF19RWaX47YvKKnXkp1CJOexWf8zpNr3Fd1BWqch6guJXqW26grJKlfA5UMq2hxwvpsIDKKs8XekKyirPKbqC4gHlEZRV6tSuoKisaVugqCxpW6DorGgboOisaJ+DEnRWtA1QqGgroFDRVkChoq2A4gHlERQq2gooVLQVUKhoK6BQ0VZAoaJ9BCVS0VZAoaKtgEJFWwGFirYCigeUR1CoaCugUNFWQKGirYBCRVsBhYr2EZRERVsBhYq2AgoVbQUUKtoKKB5QHkGhoq2AQkVbAUVpReuPjYAXm/oBFKUV7XNQlFa0T0HJSiva56AorWifg6K0on0Oip8SlGvsnPSc5nig2/ZrrTP+/uI3Kvnq9DpU8l6vZajkvV7LUMl7vZah0kPlKlTyXq9lqOS9XvO8mbbYg8rt8c20fHV6HSp5r9cyVOL2rEGl2/jq9DpU4vYsQyVuzzJU4vYsQ6WHylWoxO1ZhkosglWoXOfzi9btUTjb+mHr7EGl92YSKp96sBcqlyl7oNJD5SpULlP2QOUyD7mgcpkKFiqXecgFlcs85Fqfysa60i7zkAsql3nIBZW4PctQiduzDJUeKlehErdnGSpxe5ahErdnGSpxe1ahcp3v20LlKmWPLdsesjNme/7DoZQD7hxucJsfXwB+hLvktMdhzN2rKNy8hu0yH4eF98/xvkpBBe+f432V6gveP8f7Kg/m4P1TvC/zmWZ4/xzvqzzyg/fP8b7K80F4/9T6fZnvicP753j38K6Sd/w6nbzj1+nkHb9OJ+/4dTp5x69TyXvAr9PJO36dTt7xbXTyTl33Ad63nXdXrHvO+6Xv/QaNsbeonQm1OzTHF2j83bVbkOTlB2pANNLQSKReRCMtjVBbopGWRnhujEZaGmGtgkZaGvFoBI00NMKzazTS8Eciz7nRSEsjPBNHIy2N4LOikZZG8FnRSEMjCZ8VjbQ0gs+KRloawWdFIy2N4LOikZZGPBpBIw2N4KGhkYZGMjVrWyPZm/2nc8wNjfjj7WDGpxt0xpraT1/w2H/apdtP21S7epIz6JkaF0311hQ1MZrqrSmPptBUZ02xtwFN9dYU6zg01VtT7J1AU701xV4LNNXbn2JvBprqrKnCXg401VtT+Ohoqrem8NHRVG9N4aOjqd6a8mgKTXXWFD46muqtKXx0NNVbU/joaKq3pvA80VRfTZnNo6lXasqkW9R3QNc15TZ3BGLC7YWX9X3GczwdNBsVPQp8rQKp/1HgaxXIagEFvlaB7NFBga9VIKtbFPhSBRr2/6DA1yqQ3UIo8KV+oGFvEQp8rQLZiYQCX6tAjwJR4EsVyDMRFPhaBfJMBAW+VoE8E0GBr1Ugz0RQ4GsVyDMRFPhSBVqeiaDA1yoQRxoFvlaBuDHLKtDEmwK30tDUDzZuxNwicdG8KwXXBKW8YZ2N38HOplSUgruBUq5Kse5QirMVpeBCoJSPKQW3AKV8SCmOVT1K+ZhS2JGIUj6mFHwalPIxpbDDD6V8TCkepaCUN6Ucn2O7iGarKAWPFqV8TCl4tCjlY0rBo0UpH1MKHi1K+ZhS8GhRyoeU4vFoUcrHlIJHi1I+phQ8WpTyMaXg0aKUjynFoxSU8iGl4NGilA8pJahc+yRnj/tLvqUUE+2+xdSke/LDVid/j9pZmxpX2xud1rrUoHOSl2sFlcskRDVWVCpXVIhqrKhULr4Q1VhReUSFqHqLSuWSDlGNFZXKHTqIaqyoVG7mQVRfE1XjzQBB5b4fRDVWVCq3CCGqoaKKOOqIqruocNQRVXdR4agjqu6iwlFHVN1F5REVouotKhx1RNVdVDjqiKq7qDA/EVVvUSUK9d6i2rZjI++WW1dbd2wptt6bSUTVePaXPKJCVL1FRaGOqLqLikIdUXUXFVtfEFV3UbH6Q1TdRcXWF0TVW1SZrS+IqrdPldn6gqi6i4qtL4iqu6hw1BFVd1F5RIWoeosKRx1RdRcVjjqi6i4qHHVE1V1UOOqIqruocNQRVW9RFcxPRNVdVBTqbVGlLRyiiqUhk5z3r+uZbWtqasWXvhTqdDTVW1OU6Wiqt6ao0tFUX03ZjW0vaKq3plj4oanemmLTC5rqrSn2vKCpvv6U3TyaQlOdNcWOFzTVW1P46Giqt6bw0dFUb03ho6Op3prCR0dTnTVl8NHRVG9N4aOjqd6awkdHU7015dEUmuqsKWr03po6Ls7JtSS14BterKVER1KdJUWFjqQ6S4oCHUl1lhT7XJBUZ0l5JIWk+kqKXS5IqrOk2OSCpPr6UpY9Lkiqs6TY4oKkOksK9xxJ9ZWUwz1HUp0lhXuOpDpLCvccSXWWFO45kuosKY+kkFRfSeGeI6nOksLqRFJ9JeWXKc+D33/YhpKf/7DJZd/Oaze3yLM1v0xZDJUeKlehcpkyECqX2bwAlctU0lC5zMN6qFzmIfn6VDbWlWGZh9NQucxDYajE7VmGStyeZaj0ULkKlbg9y1CJ27MMlbg9y1CJ27MKlRGLYBkqOyxGUthx8WVzzy8OIe2053t2Qg3wrYT9G62XP8cb5PE9eD9z8EF08IfWjdnudLMHH2cOPs0cfJ45+CI4+EvA5Ra8jXfBV8Iw5ZhmLtPT7280bVpu1Gi5UavlRiVXBF1v1Gu5UcmVRtcblV2VHGGYn95EuwcvuyppBC+7KmkEL7kqaQWfJVcazeAlVw/N4CVXBM3gZa/7G8FLnrmbwcte9zeCn3mGzTPPsHnmGTbPPMOW7x7n7e4bBp/bwT93GYubOXgvOvjnXlcJMwcfZw4+zRx8Fhx8z8V6KTpu1G2blhs1Wm5UckXQ9UYlVw9db9RruVHZVcnTStxtsquSRvCyq5JG8JKrkmbwkiuNVvBGcvXQDF5yRdAMXva6vxG87HV/I3jJs3Ez+JlnWDPzDGtmnmHNzDNsj2/3RXvUrWlrbAg2Pvk9nmDuXv9ValdHv18cg7m7Nr8Hb0UHn/aNwTGHSvBOdvDmCD5WgvczBx9mDj7OHHyaOfg8c/Bl4uB7fHVhYPBxP6cRY64EL3uGbQQve4ZtBC97hm0EL3uGbQQve4ZtBC97hm0EL3uGbQQve4ZtBC97hn0evJ95hvUzz7B+5hm2fuIk2P2Qa7C3x1jv51Zd/fBGo0040SaeaJNOtMkn2pTPt6lvF2+0MSfa2BNtTuigvhU4xF334W5X2dEmnGgTT7Sp66AcbpSxj23yiTbl823KdqKNOdHGnmjjTrTxJ9qEE23iiTYndFBO6KB8Xge+/kjdJnO8FyE599iqekcmxmNrW8zmsVU+1aqcaVV/bNpsVVW4SWkfgsz96yeOVvZUK3eqlT/VKpxqFU+1Sqda5VOtyplWdjvV6pQ27Clt2FPasKe0YU9pw57SRt25NcXs9aEpttIqn2lVL4ltTvvRAFtMOVrF2hdpcva7o5hLio2LTby98GW7/XL9FS4+b3scPt+9xMVd6ohr+G7u8P3c4Ye5w49zh5/mDj/PHX6ZOvz6+8vnCd/MHf7cs26Ye9YNc8+6QdCsew1I0Dx6DUjQzHgN6LvnOiGvVTSHq2JtxVYJBVgqsMQNWGqwGGCpwWKBpQaLA5YaLB5YarAEYKnBEoGlBksClhosVLlVWKhya7AkqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaq3CosVLlVWKhya7BkqtwqLFS5VViocquwUOVWYfHAUoOFKrcKC1VuFRaldYt1N1j8477gonQmahzpKEpnohYsSmeiFixKZ6IWLEpnohYsSv2WFixK/ZYWLErrluewhE2p39KCRanf0oKlWuW6Leyt3Hb3vfPqnRqT3e2tj8V8617wUH/1/Ew34Ge/gTD7DcTZbyDNfgN59hsok99A/T0IM92Amf0GZp+JjaiZ+BqSqLn1GpKo2fIa0vfPf1M448EkgKkDkwGmDkwBmCowdgOYOjAGYOrAWICpA+MApg6MB5g6MAFg6sBQ+f4CGCrfXwBD5fsLYKh868A4Kt9fAEPl+wtgqHx/AQyV7y+A8QBTB4bK9xfAUPn+Ahgq318AQ+X7C2CofOvAeCrfXwBD5fsLYKh8fwEMle8vgFFbxzw/vhS82lmpseM1qJ2VWsConZVawKidlVrAqJ2VWsB4gKkDo9aPaQGjto5pAaPWj2kBo9aPaQAT1U7Xbtuvtc74R2DUTtctYNRO1y1g1E7XLWDUTtctYNRO1y1g1E7XLWDUGlW22AOY7dHBS2qNqhYwao2qFjBqK98WMGor3xYwHmDqwKitfFvA6H3g1gBGbeXbAkZt5dsAJlPg/QIYpW8NbKyUtL6/tgWL0rcGtmBR+tbAFixK3xrYgKUofWtgCxalbw1swaL03diNukXru7FbsHhgqcGitMptwaK0ym3BorTKbcGitMptwaL1mx5PYYla343dgkVplduChXKuCkt1Jkrbfhwl3R3TMem9TT7RpjqGJef2Nr48tKm/xja5/YZSdI9tqupPuRzopsc29kSbqpyy3YnJ/hGD+gtML+rY24T42KZaV+Zkb0J8bBOftykVfuonjMx27M40W8wP6qkfv2m2qnJkzCEGY4J5bGVPtXKnWvlTrUK91fHG1ovBX0Gjmk3Gb8ejAL9V+ipnWsXtVCtzqlWdr2APDEPYHlu5U638qVbhVKt4qlU61SqfalXOtKrvUGq2MqdandJG+oU2joHNXLysx1b+VKtwqlU81SqdapVPtSpnWuXtVKs6y84crZx7HDfqX0dttvKnWoVTreKpVulUq3yqVTnTqv7YoNnKnGp1ShvllDbKL7Th09EqPo42JZxqFU+1Sqda5VOtyolWadtOtTpTOaT6Z4yardypVv5Mq1+tTI4Vg3ePbarxFX9U5SE8tvEn2oQTbeKJNulE7Z/qL5tvtjqzOkl2O9XKnGplT7Vyp1r5U63CqVbxVKtT2rCntGFPacOd0oY7pY36mw6fjxb1lwCWw2MpttLmRObXXwTW6Kd8vk399VGNNuZEG/t5DPyJkdmfGJn9CX78iZHZpxNt8ok2dR0cOx5LelgTpLpj1GhjTrSxJ9q4E238iTbhRJuWDmptTuggnNBB3Yt63qbuRDXamBNtTowH8cR4EE+MB/HEeBBPjAfxhA7iCR3EEzpIJ3SQPqmDy1/MjwvrVWQ6ntOku7nbJFN5muKPZwLBbD9dewmsXm5+6ufNvuoILj38vBn783bsz7uxP+/H/nwY+/Nx7M//4hnf7edL4+ftVm6PES9/voXjNvfWRR7cxeVv9sfV9Vr6Yv/tHd09ajXRvg0Y/vNNwuebxM83SZ9vkj/fpD7qld1qz9tDk3qx/ryJqT9z3APL2T00sZ9v4horAvPYxH++SX1ePtZrxeeHJvHzTVKjyd0stjfJn29SPt3kFyV63keYkstDE/P5JvbzTX7llsTb6vvnu3kcZuKW3y+O9u5p+2W4+dGBH91BGN1BHN1BGt1BHt1BGdxB3EZ3YEZ3YEd3MDqT4+hMjqMzOY7O5Dg6k+PoTI6jMzn1UJHfK414t2Vo76AHB3Evm+P9MuG9g09z8KNROdEob2capcEA5x4aTPsqJubw0EEPDSZzdPCgwbKN7sCM7sCO7sCN7sCP7iCM7iAOHmjK6JGs5NEdlMEdmG0b3oMZ3oMd3oMb3oMf3kMY3kMc3kMa3sPYlL78zb3Z/nWoLjd425d9/24Wc23r39r+CgRzhOjuQnzbTP/LLS7P2pTPt/nl9pZnbcyJNvZEG3eijf98m7pR+/woyqdb1O3zZ0dX6m74s4MrdZP2yRGUX3i0z1rULdonR1Z+4dA+ObBSN2ifHVep+7O/Pqxy+Ut4mtX2ltT5Y1lm/G0giD/d0W+fHzbij4vrNxUOJd/vbjch/dp0ft4kfr5J+nyT/Mkm/7j89f/717/96V//7c9//O9Lkx//9X/+8u9//9Nf//L+17////+1/5d/+9uf/vznP/3nv/zX3/7673/8j//52x//5c9//fcf/+0P2/v//bO7rMx/c9Gn//M2oP+z8277zXm/vc0hl3+wNv9mnfvxV3O93l2ut+H24PftZy6NwvEc6ce/GGd+M8G+/6y53JGxZv9RY+3lr2n/UXPpw7jtNqm8XVN+s/42V7zFkn+7RHKI9O2f0m/OHtJ4uwPzmz86Cttv4RLXPy7A/T8=",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "cancel_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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9e5b8O476+4b5u774O7b2+671u6b0e57zO5bx+47wu4bve77t+7bsu67re6bqO57o+5bnu47me4blO77jkMA911C980/9z0996069x0494019/0y920w990t900r970o9y0m950j9w0h930e9+0b910Z980W9z0U960R9x0P940M9/0J920H990E900C975/9y5995569w5493711wLce8HdO7fd+6zdu6Lde5jdO47d+4Pdu3nde2/dO2Xd+1rdu1Dde0bdOzzd+zHduyfdex3dOxPd+wjdu/7ce/TcO+rc+9/cu9Xce8vcO8Hc+7bcu6zce6LcO5jc+40+DXDv5XHvvHHvk3HvanHvQXHvGHHv73DvxnDvnXDvdHDvS3DvInDP+btn6N3z6e7Zb/dctXtm2T0P7J61dc+xumdE3fOX7tlG99ygeybPPe/mniVzz2m5Z6Dc80W/BLjnYtwzJ+55DveshJv3uj3+bv+825vu9mq7fdBuL6/b2+r2erq9j24voNsb5/aKub1Tbi+R21vj9pq4vRduL4K7N+/uVbt7t+5epru35+51uXs/7l6Iuzfg1srd2rFbS3Vri26tza09ubUYtzbhrtXdtau7lnPXNm6uX3d86uC5vcouLfaGUz6sONEP5Lu9vW6vq9v76fZCur2Bbq+c2zvm9lK5vUVur43be+L2Yri9Ce5evbt37e7lunub7l6fu/fl7gW5eyPuXoFbO3dryW5t1a01urW30wCnAxYA3LW7u5Z113buWsftnz/bK0715PeU/N9pt62Y9fCv3rSaljslIG+OT15d/u/7Jx3/28yOR/L6e/P/x6tLiWYiV1t+d7yzu9kbmZT5p5qJzBDkJ1F+QzjyH9jf7NLg0Ej5HtMbzf8fIbbEczCvjuQdzudNzOfj70T+dzOTF0a7U07adpsq8K8jdXNp5dCwPXT0prMoe9VQKPVKovzV1XNP8AMoe0043AuxZG313ON+3NeFwz2F8i8NR34a5a8n8iMh8N8QjvyCX24Mxz6DKH8TkR+G/2wOh39B/mXh8C/0rS15+WHI7hsKw3eSBdtsDUV+Z4H/tnDkF/rW9nDkF2LDjnDkd6D8neHI70T5u8KR34Xyd4cjvwfl7wlH/gDK3xuO/MKcZF848nMof3848gux/0Ao8rsK8edgOPILY+Pl4cgvxJ9D4cgvxJ9MOPIL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",
      "debug_symbols": "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f7UWTPcWbPcWXPcWumdc6p5xqXvGpe4Zl/pnXO7dQu6e07l7TufuOZ2753TuntO5e07n7jmdu+d07p7TuXdOh23r3oLp3oLt3oLr3oJ0b8F3byF0byF2byF1b6F7TpvuOW2657TpntOme06b7jltuue06Z7TpntOm+45bbrntO2e07Z7TtvuOW2757TtntO2e07b7jltu+e07Z7TtntOu+457brntOue0657TrvuOe2657TrntOue0677jntuue0dM9p6Z7T0j2npXtOS/eclu45Ld1zWrrntHTPaeme0757TvvuOe2757TvntO+e0777jntu+e0757TvntO++45HbrndOie06F7TofuOR2653TontOhe06H7jkduud06J7TsXtOx+45HbvndOye0913eYXuu7xC911eofsur9B9l1eI3XO6+z6y0H0fWei+jyx030cWWuwj89v+4TQXkv/44mZvbQ4t9qe9KPIwbORRceQfboIOLTbqvSr0PGzoLbYWvip0M27odtzQG8x40eyfW3TR5o8v/ujTjKHFhsx2wXhNwYSewby1ELu3kLq38PzALZvfvzQrW9wq4dic9nCcudV6b5zFBltCW0ZjVEVjvzgaF47h1aV4F03hh80RuVgTf4zcDRu5NI3c2B+PpcUGW2NrLYTuLTw/DkqwBw2XUeDji43EY4L25vZ9bZNLV4dt/+Vgw9216Rp7Gjj2PG7sDTYKvy52M3DsduDY3cCxy8Cx+4FjDwPHPvC8agaeV83A86odeF61A8+rduB51Q48r1rd47vsFwdvHmPXPc4cr1MJIT3E7r56nPHGH7E7+S72t3iMsnissnicsnjkq7Uv5haPr2jfhBjifnmIafvBF3J+6OjD0NHHoaNPQ0ffdcb61oJs3Vsw3VtoMPZHvz+1kby5ysV558yb+5HWF661l+cI7xfbeGflXvltcDjmVZHLsJH7YSMPw0Yeh408DRt5HjXyBoewXhW5GTbyYedQP+wc2uCQ26siH3YO9Wrm0Ldo1MyLb9GomeveolEzf32LJqiZk96iUTPPvEWjZu54i0bNfPAWjZox/i2aLx63vd3NEC+pMm6bLbn9ly9/9j96ISEMHHscOPY0buzRaI49H7v8Ln8O5sfYRXXsRxjGbFv4MXbV40wldtXjTCX2rx5n/DHbJKnGHrO/5ap5iD0NHHseN/a0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",
      "brillig_names": [
        "discover_new_notes",
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "_finish_transfer_to_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finish_transfer_to_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+19a4xcR3Ze9cz0DKdnmt2iHiT1fj9JqWe657UriSNyhpL40nD4pihRPdM9ihytKItUDK2RpAME+eMASRYJYidB8iuPBYwESWAbSf44MLCI4SS//MdGNrERwAbiR7BGkAUWWMO64j3d33x9bvW906d6WiILGEz3PVXfOXXqnFOn6ta9nXOdkov/j7k+ioD8yt7b/yfj7yNAH/3ybzn+XumvzEwSX0v8xcr8wqTSP0P5q5MxZi4MfkXwA+m/MhHjfNjq4GNfhO+eL/+m4HPFdewjVP9l/EL2/15Pn8V2jrVcu9jwrTUEe6UVpF+zgr8aBr/tt8fNdXPb5qPyZhjZa4L/Vhj8quC/Dfi5APgnwuC3bedkGP1sCf6pGL8P25nhC4J9GmTvA7+ShH8mjG7a+O+Ekb/tt2utvnWfiH3WHrvts+ugFzubn23r/VwQ/Pm2bs6HwW/HhAth8Nv6vxgGf07wL4XBnxf8y2Hw23nmlTD4S4J/NQz+puC/Gwa/ne9cC4PfFPz3wuC356z3g+AvtOPP9TD47Tn9gzD47fhTD4Pfjj8bYfDb8WEzDH7bfxth8DcEvxkGv+2/WzG+2zl2lS9E68poTfmHMd70l3/x9oP7sHnr6Mc3Nv/ymc+/s9H8LNdh3rVqw+ujrrtEqPs6qMdufHLrs/rmrTcajc+aN28ywoiC7BJQC4D6l+offfJ2I0mejGgXm5/d/OjGJ4w2lhJN1s55qG9nE3OVYow3TvIh7wnSgg3vmbo28qxl5F8gWa3XwzniJ/KwfsSuRHd7FFnLCo3HcI/CZ4/Cp6zQOIfrB+u6IdYlQ6z3DLEs+/iuIdYVQ6xrhliXDbHWDbEs+2hpX3VDLEvfttT9BUMsS7v/wBDrvCGWpX1tGGIN69wheXvYvKNzP2YyDH7Vpwvsk/CXPCIP9XMJ/wWLacKr4LpzjRA5ktY3lD9pnFkH/dgMYk0qtBBjOuHpN/NPqq/lklK/4MHH+iXXbcMF0sVUGF3M+satADyF/zTUbTQ3Pv/w1I0PHZVR0oPo7SDVkz37Edet78kELEffD9K1UcDDMg2YN7/4ZPPMjVvNm65H8TmzDEyYBczMUtpgIfwHFSzGSZ4koxbdTSiyll23QzVanXpJzjah8NGwmoZY64ZY7xtiXTTEumaIdcEQ64ohlmUfLxtiDat9nTPEum6IVTfEsrQvS31dNcSytC9LH3rPEMvSJizjqixmAy+CFnnzEovQMLnkORoT1WPQfy68jY99inj/CeByPZYH8yZM9pJyBueCLwxmJkkfxvjthcck6ZT7VEjQldC1/4LFNOE1qA13rW/aIqnsuu2SF1wa1mRGrN3cINBsvOiRVesHL7B9i1bUidQveOTC+nfKIvQA1VttdfTANph2EXqAriUtQvvdHBI5o1JWsGRBzWvTqCzH/yt9ldsHj9gOjbDnAsf3JfY9LDwXom6FhvbPc+g0YMkcKrQitBundns9mCUPZtkj5z0ezH2AeZYw74V2GHe4aHmAjFn0/6fAk+tJiXQp4zDW6tCtxnthsVIRfqMxft51y47881T/j+PvaBPyf6wPObcW6jNb1fpWfa7eaNQ26/sIPyojoCc8jFEE/o7aaQcMrOM0y6nlHHnQG8oaKufIkzysH9HltOv48Mc36o1j9U9vfv5xc4RUyeEe1Ylw3G12lbb50TWeQkaonUxJmqmynDkFQ1OBYJbcdhmw7Sh9R1045dqIUj+XAks+j3pkScLIEUbRg8GuI32fUvDEdYqEvxx/r/RXmhzusXC418J2meRyLn1olj5lXaJNAw1lQ0wJqazXaaBj/ULMKJoGNye289unyJMm5ESF0yIMqTw93mvIB6dMntrvM+RzH9SZID73G/K5H+rsIT4PGPJ5AOpIGiD+uR9ofE/wINAsz69JHx903UVoDwFvtqmHgYbLPi6af0qfsvrnAaChbIiJ/ol6PQB0rP9MriPL/cXt/HmZg8sLeX5l1HWP037X3Zf9TsfGtkX6LvSoiD08CNcN7aGSxq6Rf8GFtM9OqvMgycP6yZjqoNoRvkRwUgfrYimBSFifV7psCvJIW5pUZ9J1m7GhijfCmlRlUfAfCoPfXj0/HAZ/U/AfCYO/JPiPhsGfF/zHwuDXBf/xMPjtR6+fCIPfkKlAYsJ7kKrJcQSeekSOqISdoisbaUOy8C+47hgXIiQfJHlYP5zKP6nIWiZaVI63OvWYNqpcG7mLdRdrl7EkhccYwDmG5i8HPXx8qeEUtJNHzLUd2eNEK3poez20ktIvXqJH5Qy1u0fBjOLqv8h18JLGAHWzGrctuW7dYFyJ/p7qgbVCWNj+KcJ6ugfWW4SF7Z8mrGd6YL1JWNj+GcJ61oOFuVZJaf8sYT3XA+tRwsL2zxHW8z2wHicsbP88Yb3QA+tBwsL2LxDWiz2wHiEsbP8iYb3UA+sxwsL2LxHWoR5Y+wkL2x8irMM9sB4mLGx/mLBe7oH1BGFhe2lbVLBit2/nTK/A9d3ImYR/gWQ1lqedM73iuvWK+uGcqaLIWlZoHGsqCp+KwkfDesYQ61lDrOcMsZ43xHrBEOtFQ6yXDLEOGWJJrJAYgLZreesh7Vwp/H1z5ajrtudnSO5RpT8a72cU3oKhzf0Yk5DmFJ5RYd2/nMCvl26iIvtUJU/ftNyXZc6a+2J7X+4rryfSbt1wnoq3uJ4kGp5GeIpoJaVf2u2pZ4iGpxFEb5j75qk/34+vT5L8xn5R4bvumq52YZ+jmSN+zu3uPofo4imPLsLErtpMWl08Tbp4KpAufPFC2/OR+tra4imlPm7bf9i8derGh0e/OF//EA9boauwOEWqx3dOnkwQa5nqPU3fxaVZDsTCwnLwbQGuv9yjPn6eVq5HRVuW8daDNmx4zbf1IPXE5J8jeZfj75X+SvsQ8gth8NsHVrUlKvZJ+BcVPeUS/gsW04RXwXWPUQj31PrmG2dMg9Ms5Z/PiDWp0EKM6XOefiP/okdWrR/T1A/W0bJJPxYWND3Z4c8var5lh19r32J6MYx+5jhVejM2viid+q3c9rHF9DBH44cx1M4Oq/Np44HwL7ju+SxEPJgmeVg/vN1QVGQtKzS2o6LCp6jwKSs0fiBqp1ia/fUj1zUjuaJywRBr3RDLso9W4+iM+3jeEMuyj+8aYr1viHXVEOuiIVbdEOuKIZalTVj6o6UPWdqEpb4uG2J9YIhlqftLhliWur9uiGWpL8tYeM4Qy1JfwxoLLfVlGXPuhJzJ0iYs520r3Uefef09LHZvpfvoM+8BDIvdW9qXZZywzAEs9dUwxGoSVtp1vdQvKfW1fUHZS8bbYdJW9lDwlpfhnsWsT094C0747+RheNHbHNVbbXX0wP64NwHL0fc5ujbq9IfhtafxJhLkFL48viIv62xcqY94/FTaajzwkR4PxBfLikzTgH8uJog98NGA5fh7pa9SqxZjvMOuU0SXwjvMcZ1q6gd+hX+BZDX2jfZ+nnYsC/XD+3mvKLKWFRqPoXZM6RWFT1mhcU7TD9a7hljvG2JdNcS6aIhVN8S6YohlaRPXDLHWDbEsbcJSX5cNsSz1dckQy0pf0We+hzAstnrBEOubPo5RuW6IZakvy3nonCGWpb6GdR6y1JdlvLe0L8uYY+mPljZhmTNZ6T76zPtTw2L3VrqPPvP+1LDYvaV9WcaJYc2/GoZYzRirFNNwPcmPgGiPPB3y8MH2h1JgaethqV9R6vv2wdDupa3sPcwALcQ+mLbWx8cohP9O9sFEbzNUb7XV0QPKgLpgLEffZ+ha0j4Yn+n6T7HyRb+Bzkqqx9/5UQbcO+OztLgP59t71c7STiVg4Qv68Bed8W02WP8/w77dQ8XtmL2OaMsYa33ls67PJvDPuY7N5anuD0C2R2PZiq5bT6L/wOO9mSN+ohe8hvwHdTZPGyfNjrR9VkN5NtLEZZSX92W1GC9xA9/ChPUPQR85zmDcy9O1346VUnbdsf54a7sMh5X+aHNDtKf930e2922nZ74RV5u/ZHyFDz5KLH4fyfM7I9v7wnEC20af9wMd6/90uoP5P2LMktKex499EWNRVFZa2+vLeMr9B67DcUzq/z7EiicojvV6k1dSXoEv3USZ5TUJLMMf0LwTaA9fnXeEV4nk5fHhvmhjwnb3kqKHotKO43CgOJM6Dgv/Qb1ZzPcIPuo1sH1spIlbKK+M5csKTbAkZ0MfwvqHoY9YHz9Le7z2Y4rDGLM5Dmt5rPbIexQ7fkQxCvtzkPqWdR2B7VmH2K7feK/J7PO7nfJBLMwZcVyTYifew8fxwNiJdsixs10/FjSK3097cj2c28ZHe8s6pciap/q/B3PbZIwpdlOC9jIe2viUiHZQ4Zujug7kxDo8H4mc4wn1Swn9KoNOD9CciLrQxrWUIMOY0q+o8LhK/ft2MK4PjPaWVVtr5Kn+b8C4HqRxRf35xrVMNBxX0ZE25/KYZ51zsf1BD5/7iYa2I2+ILdJ3oUdF5iKc4+3mos3Ujx8L/wLJGmqu1l69g/oZzJpps5JmDkJ5A+cOVe28R9LrP9AfsT6vyXCvCffN8nRtLjYMLR8RfMs8YdBYvn1RjvMvki7QXnMJ/wWXr/nyeY4RIfKXqEh8lzh1WJGB5xrhw9eYD7aXepqfRH/L8fdKX6U2o50bs8OvVrTXWhnit+WvhMGfFXviPVwcm1m4bhfD5lI/Qyv8CyRrqDlnluRh/fCZu6oia1mhsY1XFT5VhU9ZofG9r2HBumiI9a4h1vuGWJb6umKIdc0Q67Ih1rohlmUf3zPEGlYfstT9BUMsS7v/wBDrvCGWpX1tGGJZ2td1Q6xNQyxLu7ccR8v4ZdnHhhFW9Jlz7X7karbssCz1ZZlP3AnzkKXdD2v+dc4Q66oh1t38a/fs3jI3uTunZcMa1lxuWGOhZS5nGQstx9FSX8Oaf/Fe5Dcx/7pkiGXp25Y+ZKkvy3nI0oeGVfeW8ctyL21Y94Ys7csy9x3WHHNY546Ks8GKiswdfG8w+ozv3Q57n6lSFfxaIHyfrrBPwr9Iuha69l+wmCa8Cq573ELcE9P6hvL7bAp10K99CtakQgsxprOefiP/3boXGH0+aIhVJCztHr92L1Tq15T6mp2UFN7SVsZ2DmiGYzvrG1uMEcJ/J89bid4uUD35+bgR1+0b1QQsR98v0LVRpz9vpZ3hKCfIKXz5mu+822EPnxBnRb5p/WFsOWel/Sxj2HMyC4thz5nMb2jPUNrhz21pOYSh/LPafGOHX5uT+aNGtoFjHyYezlfT5hzCv+C6Y2WInGOO5GH98DmceUXWskLjMZxX+MwrfDSsw0ZYUeF7Sv1gXTTEOm+IVTfEsuzjBUOsdUMsS5s4Z4hlZRPanHPXJvxY1wyx3jPEGlbfttS9pb4uGWJZ9vGqIZblOFra/WVDLCu7jz7zu3aGxSYahlhWNhF9vpt/7Y6tOjecc230mdeYd2OhH6tpiGUVc6LPvJbvB+tFI6yoWPqQZYy2nNOGNS8c1jltGNdWUbHMTSx9yFJfVjH67tzxzZg7omK5trKMhdcNsSz1dXdPYfd0b9nHTUOsYV0PWer+iiHWsO4XNgyx7saJ3csn7saJ3dP9sMaJJmFpZ3/KcG01ri9nHCqu057vi871wFohLGw/53r3EbHeIixsL20nXfcYR3/L8fdKX6XWFPyFIPgLdcFfDII/25D74Eug1xzp7ltw3e6efS31ux6Ff4FktZWnc4bgWyQP64fPEHxbkbWs0NgGv63w+bbCp6zQeB7sB6tuiHXREGvdCCv6zPdI+pHrnJFcUfnAEMtKX864j5bjyHF2WGz1uiGWpW9b2sQ1Q6y78etu/ArZR0u7P2+IZWX30WfeWx8W3x5Wf7SM0cM611qO4wVDrDthHroT+mgpl2VcHdZ5m9ftw2JfVvqKPvN5qn7kumIkV1Qs11bDOqfd9cfd6+Owztt3wjrNMkbzmbFvot2/b4hlmUdb2teGIVaIGM3PY0ZlOf5f6atUa7IXjc8n59x2vrj/bLhv3swRP9ERXkP+BdftdyH28bX7R6ifEdLPQhh5GjnCR3kWFP3IWC4qNMGS+wz4Ow1YfwH6iPXxs7THa7+Yv/2/rGBynreo9AeviX6j3zz4XoybwQdmN7dmqnPNhbnKfL0215ivzjZmFyqN2tzWzMzizOxSbbFa3dqsLTYWZ6tbswuzm/xMp8iKfAONcS2tDwj/ggvqkzM+m9PuE2s2J23ZFqKy1urUy2ILlnalySW/VcS/Pyn4UQlrC9WNndpCoN998dqC9v6BLLYQfX4BPvc7fpxT94N1xRDrqiHWRUOsC4ZY64ZYdUOs9wyxLPt43hDLso/vGmK9b4QVfeb7FcNiX5b+aGlflrHQUq5rhliWdv9Nt4noM98jHRb7+sAIy7qPlnZ/yRDL0u6vG2LdjRPfjLnDso+bhlhW+URUhlX3DUOsuz6Ube7g8/t3fejrqXvLtbvlGrkZY8ke0gtAW47/V/or7XcPv9g/doMvaO9UtNtrqlXCPg/RkX/RXO/VOX7ewQ670n7X5LftsWd7/eb6s+Pbx+LVuE7Sb64/DXSs/3cmOpgvxJjSr70uxHjXaml+3xx/297OlmcrOeLnnL6PK/wH9fvm+0ke1g/v4x5UZC0rNB7DrL9rjzSO3/1gfWCIdd4Q6z1DrA1DrIuGWNeHVK4LhljrhljnhlSuuiGWpd1bymWp+6uGWJbjaKn7S4ZYln1sGGFFn/l3RfuRq9myw7LU1zVDrGH1bcu5Q/IJeW4c88eX3HYa2tIh4vcg0BBf8tKHgW6ZBwr+o2Hw279j8ojr1jH2SfhLnvkQ1M8l/BcspgmvAmFZ687XN5Sf7ecRkAd1kIT1SEasSYUWYkwf9vQb+Rc9smr9eJB0ovHR1ihS/zGPXFhf/BJtX9qKDh8HmqEOZ33j/RjwFP47+Q0Y0dtjVG+11dED6/7RBCxH3x+ja6OAh0V0jOvY/YT1APUhaXzLSnupl2ZtHyYOVFP/foXwH9Ta/qGUehXdPazIWlZovLbX/PNhhU9ZofHavh+sDwyxzhtivWeItWGIddEQ6/qQynXBEGvdEKthhBV95nVJP3I1W3ZYlvq6Zohl6Y91QyxLu7eMhZbjeMkQy3IcLeOXpb7eN8Q6Z4hlqS9LH7LMJyz1ddUQ625c3b24aqX76PNzzgYrKpZ2b6X76DOfvxwWu7e0L8s4cdkQa1jz1VecDVZUmq3b/8Ou8Suzw7qnhr/Vmkv4L1hME14FwjLu24yvbyi/z2ZQB/3an2AF3ltvj+lDnn4j/6z7MGn2SdPqZJqwphUs355r2rEtue7xlLaBfay95/qgS9YT8t/JnqvobZbqrbQ6euCxeygBy9F3fh6/154rjun9REP7KxOfvdS/Xn6K7fd6+Bzok8+BlHy+zv3pdf7u/gmdZ9L5u4NAx/oNOH93YGJ7H7H9PredhjZ1L9GKQLuPaKg3qSf+XgKanb/PVESXMp5YhHYP8J4i2j6gYb+5jNJ37FMUP/4EcLkey4M6RNkQE8da02ue6j830ZHluaKOmQNMlHO1tb2+6HLcdfqNdVgGqf8SyPBEUcccS+hXKQHzKNjwyxM6pnO6L3K/7qF+JcWUPNWfhX4dAMVhHfmOc6q880B47VN4uYRrbBv7EmhZ+aJ+5Nq9KfjmFBrbEusT2yfpnG1J6r/qsaWiIgPqg8d9L8nAde4hGaT+siJDpGeJIZs3Pv3iWP3Tm59/3HRUxuAzh3ptqHkIigpOUhE1RN0Td2Ec+e4zE80dXcK1pGGfhuuN5sfNW80EBY0Q2FQCsxGnF46l0i4qYeec2zkm8nNOX3sJ/4LT7XbZRp4ZjvMiD+uH7wWXFVmz5kfYJ44vafIjX+zYm7I/065j2Ddv3fgsyeZwDtdsbjqBf05p76htTrkWlcgpz8VOOUl8je2g/T6jaUVGLffIEQ37y7bCvoQ0tJUxouF8kScazi3jRLsXaBNEuw9oe4h2P9AmiYZnMQrwmYuW68mYRfx+CrhcT0rUn81Y8KjtN20Nw1gjrnttEhX5zR2x/TDnYTYrIo+suZPy5weAjvVvwFz/IuUb2tml/Yq+WAasj/3msUKb5f0ejbeW44bdG+3o92HQn9a3h4CO9X/Oo19t78yn3177pyKP6Bd1+jBh9dLvSuv2/2HX71/fRf1q+5zamUCOd1nPBJY9MiCfA33yOaDw8WGVFSxcJ3yZCH/0V5qfnblxq/3qS4FEtTr6PEnXpuk7p773J4ialFrL9wfpO99ueJK+36PIpxWRAwvLMup6FzF10dXfBlM/TKauTW3IU8Ilb8FhW9yCE/N6DeqxGb+m8MRrPjOWehoffrTgdaVdjmgow+seGbC91JMQdwRodiGu1g5xgpe0nXkE6Fj/H3lCnLTB/j+l9J9lwPrYb5FH0720LSq8cwn/hQ9f43FBGZ4ZEJ9n488lhca2run5iIcPtj8yoP6UB8SnNCA+xQHx4dsTy4Z8lqGO3K4Qe3sDaBzX3iA+fM0X196g/rxm2B8tThcV+frlg7rhx8mOAg3nOJHjmCKHxPgVuG64BZH6tcbCv0CyGsvT3hpbIXlYP7zdsarIWlZo+LMASEM+qwofDesZQyyxjZLrtpVjxOeowueoh88xhY/Y1ZtAM8wdFmVc3nLdRWhvw7WtVkcOLtr2jsgd5RaVYgeX6zFP1OvbREMfO0E0HKuTRDsOtFPx55Lr1i/yRpr0ka/xOGL7N0kGbNdvDNNk1uxyhfqT1S5XFD5FpV2//dFk5jG34IP9WSU+q4Z80BaPE59XoR0eUfgjuhUr7TCnx7ayDZin+r883cH8U9omfxvkMowldenbCdddhHYSeLNvnAIa29lpoLFtnAEa6pyLFp9EF1F8OpshPr0FNOmTjIHsD/w53GL/ycT29jiG/Kp8nD+PE+24QvtqjAsdeVAPeCwA9yfYbqT+gXjfP+y8M7+gzS2cS50IxDuNP2tzC8ojchcU2lgfsm5tLlaqlfn5RnO+tjFX28q5bp8aVa7xOvykUr+m1Bddnwqj61nxpdFWBx/n5aiMAe0E0fJAExkjE/2Z4nb5TwaSP43+kX9Zqf8W9CHLWIbEwnhggbV3h1j7XPecJDEncO67pMUgKZrPV4iGNlclGvrTHNFwLsPbxlx65dOfZ5ivcF48kYApcwGuBWSOyVPd5+N5Ipp7ntmznRfmhG+3ttMw9xI+EcaRPZ3ryAfP6cg8GZV3EuR6leavQLlOQ8t1eP46GYh32vmL1z8oj8hdUGj9zF8bM1vVZmVjoza70Zibn5/3zUd4jeevU0r9JaW+6Pp0GF1vaPPXKdBrVMaAxnMbzl8iozZ/hZl/axtp9I/8y0r9M9CHLGMpsV3Lm7R1/gLRcM2Hue4R8vEweeLtsee+OZIRx43nB7RJnh9wzcLzwztAyzo/iC6yzg8YJ7FPiDkG17QYn6f6Z2COOEVzBM7pwjuq9wOqd1KRO6zPpN9rFf5aDA2x16rFRM3vNPtj/z4N7c62OvWYNqpcG0nAij7ja9r6xRK7KLluGz1JfN5W+Lzt4XNS4SN2hf5nN45z7Ucq1lx3EdpZuJZ1r1XkzrrXino9SzT0sXWi4VidIxrGt/Px55Lr1i/yRpr0ka/xOGL7d0gGbJdL+C98+Brz0WTW7JJjZ1a7PKXw8e2V7LQ/msw85hZ8sD+nic9pQz5oi2eID+bouNf6XVpzSDvca9XW3nmq/w9gr/WvUm6CfrBbsUTzjXWgsZ2dAxrbxnmgoc65aPFJdJF1rxVjNfYJZU+bm0j9X6BxCpRLVPZRvzSd+vZAhy3HCbOe9uc4WrzMkuNEn1+Azxx7suYlK4ZYYtsl5xLzkhzRkM9JDx8tX7pTcxwthgwqx+FcNWuOg+0HleP47JJznKx2eUrh41vv7bQ/msx3Wo7za0Y5zl+DHOc/DmT/xTbHYTsLlePg/kuWHMe3Buu1V5Ij3km50InW7f+8T/NbsE/zm3uS5XoTeB+b3F7v7j7NnbtPI3ahnaXiuS/rWSrtvMidmsOgXgedwyBvpEkfe+Uw2H5QOYzPLjmHyWqXpxQ+RaVdv/3RZL7TcpgfG+UwH0IO85Ov4T4N29nXaZ8G7+enyU3a5xziPGMY9mmOKv0Pe0YlfY4j/Aska6gcR4uX2hlibX6Stlrs4X0aLZc6pfDRsFYMsXg9rJ2JzhEN+ax4+GjnngOfa2jy/I9Fm5ez5jgid9YcB/XKsRB9bI1oWfd3Sq5bv/3u62H7Qc2hK9QflIFztqx2+abCp6i067c/msyhc6nd2ndKynFqk5022C5tjiP11yDHWaC5M9A5mUyxRPONNaCxnWEewbah7e+kjU873afBWM3xCfdKpJ62V6L5TuA8opnGlrU8ItDzjN48QotJkVnLz2t92Ly19vnGxx9tnmx+cfONTxpr9c9ufVT/+I1G47PmzZvYG7Ya7i1bC9eRzxXlOmKc6NGL1dbt/9pK9ARhneyBtUJY2il0jiJJWG8Rlha5eObTvI2zKayP8pzuIc+brWR5ThPWGQ9W9FneaqHN9GcI650eWI8SFrZ/h9qtJfDBOhgN1xTeGj7b7dkeMj9OMqNcvDpb74H1IGFh+3XCOtcD6xHCwvbnqN35BD5YB1fB54F3TrmmyfOYR57zhHWhB9Z+wsL2FwjrYg8sfuEPtr9I7S4l8ME6F+H6JeCdU65p8jzhkUfappnhUFbDGSX1qXjhP6gZzqfXqPBK+bIia1mhcXZ/WeFzWeGjYZ0wxDpliHXSEOu0IdY7hlhrhlhnDbHOGWKtG2KdN8SSmKjd8ZglPlnveGD7Qd3xmCU+uCOHq82/R6tNsUFcbeJKB1+eh/WXYLX592NMbSdCZNT0zLsuWfWs8ZG5Bm3YcFd/XvSLc7gUoeE89yJ85qKtTkXurLtnqFeekzHOXCYaxo0rREPfvRp/Lrlu/XJM1PJAvOazY75Lie369RdNZs0uOS5ntcs1hU9o/+dd0TVDPtr6ge3Hgo+2tugVz36V4pm0S4pnTwAd6z8J8ew/0O4Z+sFuxhL2DS0vEdoVoLFtXAUa6pyLFp9EF1l3zzBWc3zSfGLSddvebtxdE/4F1+1zIdYM2p6AFmu0+C1tNX/6Fnxmvx1Vrvl8c8UQS9aSvtwhRzTk47uLoeUagfODGt+Fx1KkPkcl6921neYHqNcLREMfu0g0HCv2W4yLEou0/IDtJWt+gO0HlR/47q5xfpDVLn13PULdXbtT84P/myE/iArfXZP6U5Af/BnlB4FOI2aKJZpv4L4f2xnmFWwbSfsKXHqdcNzp3bULgM/6xXpjTt+vfMcly5VTcNjnjibwj8qp1nbaWgrZkvb8ndPjiXanMUm2NUU2xh3x9COJjxajtFg4T7JnjYXzCp80e8mB8sJqmtiE/Ae1l7yWUq9Z80L2i35yuaMkA8ZVHr9AeXTqvF74D+rUnLaHMK/odRD2nTTOKx55wqyBOz8uq+WE2qnC6JcSxl1yXE3KE5AH2kPS2CDv1dbt/2nWKGs9sFYIy7fvdLYHFt/D13TAPsz1NOwk3klznVOuS/6EuuKTVmeprnZSSHQh4ziSIMNZoONYc19ySn0Nj+9Hn1PqISbff866ZhE/w3xuN+Ki8C8o/Q4RF7X76tpaMPL7Cbdd12wzOH5J50fOKH3leNBLJo4HWe/1I9YKYWn3+i3XutqeY79YlwywtDX4eaLheuYC0XA9w3nIZUU+8TfcJ90NfxP+BZI1lL9dIXlYP5q/Jc132hrBV+cK8JVr0d/VHjKxv+GYXSWsd3tgrRAWtpe2I657LLRzUu/2oGv7Yw6uXSN+iHeF6l6hutpZpaTv1zLgogxXqe5VjwwXqO56Ah9tzC4ArlxH3Ys/Z40R60TTzkrxfe3Lhdv/oxzzWiGZ70kP39MevjL/ID4/rfY+yLDhkWHFI8M7HhnWXDf+iOv2Y8xlR6jfKK98x76PKHJye6RhfcxVBU87F3qOaDjPXyQ+7yh8ks5r4vc9Cf1g/VraBvMT+6goPDjP/rTQkfvB+NXMafZTAj0Zn3oeFP6D2k/pddaacxztDLTviXj2B+Tje5IIsU4YYsnZvDv16TLfU+io5xBPl/VrE9h+UE+X+Z6gZ7vM+gT9CYVPUWnXb380mXnMLfhoz2Gw/Vjw8T1dlnT/65fo10G0p8t897+k/v+b6mD+kxgz8BusTZ8uYzvDHINto5+ny/CXKnZ6Pibp6VdsG/bJvspc2nmb3yYf6Cm29rytPW+lxZrodq08k/Fh89bJ5hcX6x9/1Kjf+ujGJ+vNn/28efMWdgOhx+A60rGMETupt0L1jre662EZ1MO7adX3ZitZLnaTXTDL2tfdLLW0QtpqYX4RPvN0Mqpc800Z/b5UErEG/fB54KmmoaVTUrRpKGvaitPCTo9t8UtzfC/AzprSlly3fvt9iQa2H9QLjHx2yfaf1S7fVvj4ltY77Y8mM4+5BR/sz26lx0lp6w8pbcXtjjRpq9T/IaStv0dpa6Afl8oUSzTf0I6taikt24aW0qaNT/jjUjs9tsXxCX/oUH60SWjHoB3/ECf+WKvg4w8dar4tP7pdou/R5+X4c57kyse2MUn1bO2h2rYH7QdGw9piNfWjsUnLcJRby6XG+pB1trmxOV+vb1U3tyqb9a1mjvBFVr6GW7gcE6X+YaV+2Ny0Whd/wR+MQh+NyhjQ+PUUeaDhS0r4B6PCvIi9Wk+jf+RfVuqvtjr1soxlmrVLWiz58Sn84bvl+LMWm9gXl+H6bqxdhF+BZDWWp712WXbden1V0auWk0pbzl2iwi+tzZpvafHdAkvmHm2ueJX4HFH4HPHweVWReZh+zDIqWdcuO/0hd9Qr55fLQOOc0LduQJ+W/ErbomZ7yRqHsP2gtqjT5DA7tctlhU9RaddvfzSZecwt+CxDnUGtxThPTVq7zEx12mC7tGsXqf8DWLvUKFdFP9itWKL5Bu4tsJ3hOn2ZaHjrCXXORYtPoot+1i4cnzSfGNb84EgYebz5gRZrsuQH0ecX4DP7bdY5/S1DLLGLkkuOnT7dLHv4aPHxTs0PloHG/qcd5bXMD5bhM9Kkj73yA2w/qPxgmfqDMqC+dmKXRxU+oefto8TnqCEf7M9u5Qe4hsL84GdS5AfYNik/+DeQH3yH8oMwc4JtfrBMNMwP2Db6yQ9EF1nzA1zLnUjAzCt1Xyea1P0ujNcvx59LSvvX3Hbaa0B7g2ivA+1Voh1RMDk+oM1h/Rnqg9T/G7HckS4f2atjjjg9TxA7FhtFH7Wz0c0K5wDYx2XgeZT6KPX/FvTxRbIX3NsT3cdPg7uxVpD+zERyPE5HOcUOvpIf+HIcHVXq8/6plitp80GavOt1BWsZrq22bv/fTRtAn0myge+ltAHR627YgGB/JT/wTbIBrJ/VBkRnvv20nOu2NdZ5VAZtAyIf2sAbwJNtQOr/05Q2sOw6/YnKWCtIf1QbQL2msQGszzZwTKmPYyM6K7vucT9OWMsKFs4FqySrYI87fT4SvDzV/z6M0YHidvm0OVlorynYOC/nCAP7MaX0o0g0bBvhPju+XX7J4f4t5AS/QTlcmPs8nUfAJafR8k7kzz8a+CuKX+SoDepL2ytgGbD+24oOS6Q3bBtWX7W6tkaWouW1nPOm3ffinBfPCPAaBs8IoE64aPmw6Ckav3mIJ1xPCtpmjngKD/YV9otXFXlxLcR+8V/AL353CPwC42CSX/zXjH6h3WNL6xe8R/V19wveK0a/WCbaMPnF76bwC5yH2S+OKvLiPQQ+z/S/wC9+RH6BOgvhF9qP76H8p912maX+//b4xWlFX76zHtpPP2gxVHtcUNoO0yNQ6AfaGS+2bzzjxee/8LEF3k/VHk9M6xeipyx+8SPyC+2scVq/OAm4P6RHZkV3/x/8Yk/8qrawP/DY8QsZyyS/QL/B+j/x+IXvJ06iwn6hvcIG+81+gbGXX50dRl+1raIiqxTN9k8TLe0PQqWxfaHhqztQJ1w0v8BHhNP6hdhmjngKjyx+cQpwf4n8ov16RHht4WPkF9j3EH6Bj9hrfnHebZdZ6t8Ty6n5hfaTLtrrcVkGrI/9Zr/QXmkQVl9zc0VFVilCw0fI+XVC+Ag5zxfaz00IDV/JwI+24isa+Od3sGh+IXrK4hePkV9or9NI6xfrgCuv/2S/eBr8Yn4wftGQvslYpvULqf98Rr/wzRfaa4nS+oW0DewXQ/V6dKFpr3wJ6RfzgfziV+knO7SfLBCevV5DJzzDvlq7ssm2nuQ/54CO9Y94/Mf302VRYf/R/E17RZzvp8V2M96cVeTheHNc0Ze2/70G/YnKWCtIf5ra/jeOWx749hqjqGSNiaKzNK8a8v2kyVEFE3+ah9c26zBXNYZgbYP395PWNhc9vqatbTCeZF3biDzflLUN53AYO3jdM0xrm0aKtQ3uFfJcdUKRF38gmfeVPgK/+Hnyi0G9PjfJL9bcdpml/nc8fqG9OlZ7Hts3L2O/2S/Q9qVtWH3NzRQVWaVo9s15Gto3275m37yW0nwN4zb/TCsWzS9ET1n84ufJL7T4l9Yv8PVxP47fTcZ+0QK/+N7XxC/+Zka/wPspd7pfpIn7w+gX3wvkF7+W4Bf/EPzi+18Tv/jHd+eLdsnqF3x/5OviF98P5BffJb+QMzv/Gvzi18kv8HxfCL/Ae+naGZS33HaZpf6/8/iFtEF9HYNr7BfavXnsN59BwbNO0jasvmzPXfM5E+39Kdp9eD7fjr6AOuGi+YXoKYtf/Dr5xXHigWMVFfaLVxV5I9w/mrj9Wca3DPUOue20w0A76LbL87IiD9afovqvgAxafcHLU/3fBNuXM29ifxVob+ivGyIzngsfVfpVIZml/n/z+Ku0Qb29BNfYX2eU+thvkadEesO2k/Q9lL5mFX29rMiTp/q/nXLvrQz9icpYK0h/NrW9Nxy3PPDtNUZR4TGdVerj2IjOylQfx1doh4BWIRr67GGSoazIkPasp7SNfPmBOOBpMYPjCdoCx5NXFHmwPseTCsig1Rc8fp30H3jiSSD/qPv8A/uV5B//xxNPNNsrwbWstsfxBGONtJ103XYZIp5UFX29osiTp/o/ShlPDkN/ojLWCtIfNZ7guHE88Y1RVHhMq0p9X8yoAo1jBsaTGaKhz75MMhxWZEgbT6Rt5MvjFE+w3rPE85DCE+fSldbt/5OKzCHuPWHMGXXd+kzKcUZj49T8W8uzDsA1toVecdSX40nbwPra8OnrpRT6Kij60vx7CvoTlbFWkP6o/o22yf6tjSnWzzqmorOy646Rh4mGPnSI+EwpfNCf2IdxrKRt5MO/E3egAHT5P+Z2rvfNjfmNWvQetZnafLVWaewj/KiI7qYC8K/N1Rc26wszM0u1mWZtZm7Q/JsbtaWFjaXNuUqjsjSzVB00/4X64pfcl2r12nxls7IwP2j+s4uL80uzG5XaQmNzq1EbeP83GvOblaXqTKNeX/iy+4sD73+j0ZypzSwsLTZrtcbS4O1vcelLw9tq1mdmZmYbleag+c81NhYrC7P1pcbmfKM6t9mLfxSX/zD+LjFrBOpKO5nvRuG64fyQ+l03cq1AshrL037XzSjJw/oZId2NKbKWiRaV461OPaaNKtdGBoxVct3jzXOupptRDx8eq6gUlXZsc6zT5fh7pb+S+icNhH/BBfWBGd/4aXoV3eUVWctEiwrbSV7hk1f4fF2wpH1U2B+jcrq1nYZjzDpNa6vyHheOpSWXPDbCO34EeNv1vCJvnupfoj2ZCZJ1Of5e6bPw3IG8JpX+GfJun/Udd92lqPSbx30P0HhsJ0lmpOF8zL/7gWWUvqMuIt4/m+IehmYjOaKNK/0QGo97VMqu27bzREPbHicaxrYJoqEvyfu7c4TpXMdncexWW9tl13xvCq5PtLbjffUfruXjz6LfPVifaJNAG2t1+EalEH8fAz6IJXLkqf6tGFz2EcehjbQvK/zHif82uZVrOFaMNapck/pfvQMqljEpz8Px4Tk3UExJPecK/4Lr9oMQc+4EycP64RiyR5G1TLSorLU69Zg2qlwbScBin+kXa8QQS+KC5tvjxCen8Ml5+HD7qEwq7Zbj/5VspcYXBJvniB3ic6nzPINF2/fV/AX1hwXlzvruRbSHKaLhPDhNNIwTRaKhjcTToTf+79RGuD3KgO1yCf+Fj+vBR5O5pMjAeZ42N454+IwpfHxr8532R5NZy5v75YP9mSA+E4Z80Bb3EB/Mq/Hdi/+c7iVIO9xvx7Zvtjp0rD+6t4P5ryg/Rz8wjCVLnM9i0fJZ9g2MM2xn00Bj2ygCDXXORYtPoous717EeaBANM3HJ123je/GfpXwL7juGBIij9FijeYzWmz37QtxHrPTPSYey36xROdaHM7R56xxWBvHwPnxIs+dWDR/32p15OCi+Z/I3U9+MEk0tHv2TRwrzivQDiTeaGtbHlMtV8drvnluUPOPLz8Ypf5ktUttTzZ0fpBmv3anfLDOoPKQceKTlB/8T8oPpF1SfsDvZpb6f1zsYP4+5QeB9tAyxRLNNzB3YDubIpmRpuUOaeMT7qFlyQ/QJqRPU657HP4UxkEWJYHztPbZdpFLsx3kn6f6f+Y5+6Kt2zUfYBmwPvZb5NH2H6XtsOW1bLdp81q2W8xrOQ7tBRrqhEuvnDft2XZH79IeJx4cd1Zb2+XNK/JiPOP1Sx7WL/vJLwLthdSkbzKWSX6BfoP1J2M5Nb/Q7Fzbz2MZsD72m/0Cbb8tT1h97XjvSLN99ou0ts++VgIa6oRLr72qtH6xn/xCi39p/WIP4Mo+gPl5oNnNuXp1bqmy2ZxbqM8vDPw81taXXLcWKnOzjVpztlHvxV+7n4HnBaMi90TwngnWF7w81X8aYsyzNN55hV9Ub85TL5fw/ysM5dpYa/s17V4K3mOS+sK70OqWUWhTQMsTn+n4O+oLsUSOPNWfjfsuY4L3haR9WeG/h/hvk1u5xveYppT6U0r9aHxeimVsx3Dgbb2/8RVPwsdrLJvYTtK9eb6nhDRcy/F+rsQNbV8zKnzfXuq/Nph5Vb1vP0l9mIA+aPMjr2Ok/mXw4eW923Wm3avxree1uZTHAeUWfYv+psLor52vy3yJeQnKOuW260jqv6XkJdrZ63HoT1TGWkH6U9POXmMOgT6L/XKu02+sz7nTtFIfx0Z0VnbdeQiffdDO/uAcv0qyYm7rW8/wOvAcjBH/TgD6TYFk1/aStH0MPnOBsWISZP6UYkKg+9wL2n6XFO1+HeeO6IecOxZIZqShHWTdCxBdZD1PYxGHMAf+Sr5Wt1y74be4rmG/9a1hnOv2215+LvtgZdc9lmzf2lyTxWeiskr80F4wV/80YV7vtZd3K2FNnXUv7xdgDvw5mgMtz3L1skseX+EnsYT9cjn+XumvpD7DI/wLrjuGhLj3pdm/tuYPnD/UfPOi5o/3uNtrbB4zlE+wcD9c7kX79urY1nvppqy05zOCOMa+s4UcB9KcLUR7n3L+XD1HWEn7RzwfpN1L49z374Lf/3vye+0squa/7PfaWVShaWdRxXZ5H3M5/l7pr7Rtt73edrpOMTfG+r/o2ZPT/EE7Y8YyYH0td9Seg22f/aTvxvpqrxX29tBXkfQl9f+ZR19a/yc8+tqr1C969IW6xLbMOykWDcoWe+mWbVHq/8uU67A90J+ojLWC9GdOy+cwB8sD3yR/wfppxl/zlzLVx/HWYjzHau2soBbjOf5jjJfYhrG0170Lyd/+Akwa8ZOzUAIA",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          }
        },
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACYHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADBJwICAAUvDAACAAMeAgAEAQo4AwQFJAIABQAAAJElAAAA0zAMAAEAAiYoAIAEBHgADQAAAIAEgAMkAIADAAAAwCoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFedUGXr5zdNI8AQECJi4AGMoYyg==",
      "debug_symbols": "5VXRqsIwDP2XPu+haZI29VcuF5k6ZTCmzHnhIv77bcVuU8cGIr7cl7GMk56T5Kw5q02xOu2WZb3dH9Xi66yq/Tpvy30dovMlU6umrKpytxx+Vjo+HF/xx0Nex/DY5k2rFkCidaaKehPfPXI4Y1tWRYjQXLJnvDYmwTWZHm38CJos8Q1NlqlDC46AhcTfwMKah+DvTIl+j3yfOADAf1D+m7rP0nVf5roP7FxCW8Rp+Z5dqtVbkAf5Ht8tH8y9/EgiHyABbT/BAjDGghqTR1Cz67Kit54pAHuv2t59IDCCdmyTIMfip4ft0CZnONJ2Ghx02K41QRM+eCOI+z+1GjNeq8Wu1ih5qlYSSOpJzIwgYbbdreLgSY6bbb3QUE5MQvNCEulXkkZvPQQDKSmcO+MMNKm1gORnnCHapPHJcD2NO0O6o504mnMG2d6iDPpuFJcQ/eRNma+q4raJt6d6PVjM7e+heNjRh2a/Ljanpojbul/UEDttJEO8/lwhQJehDxyB5w8=",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "transfer_in_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954044801249163952": {
            "error_kind": "string",
            "string": "NFT not found when transferring"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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/dTSqGU3tST36aeW5D791JLcp59akvt0k/vM5D7d1HIh9+mnluQ+/dSS3KefWpL7dNPHLkYtu6kluU8/tST36aeW5D791JLcp59akvt0U8tM7tNPLcl9+qkluU83uU8m9+mnlkYtu6kluU8/tST36aeW5D799LHkPv3Uktynl1rOA7lPP7Uk9+mnluQ+/dSS3KefWhq17KaW5D791JLcp5fcZx7IffqpJblPP7Uk9+mmloHcp59akvt008cGcp9+aknu008tjVp2U0tyn35qSe7TTy3JffqpJblPP7Uk9+mmlpHcp5vcJ5L79FNLcp9+aknu008tjVp2U0tyn376WHKffmpJ7tNPLcl9+qkluU83tUzkPv3Uktynn1qS+/RTS3Kffmpp1LKX3CeR+/RTS3KffmpJ7tNPLcl9+qkluU83fayR+/RTS3KffmpJ7tNPLcl9+qmlUctuaknu008tyX36qSW5Tz+1JPfpJvcxcp9uajmS+/RTS3KffmpJ7tNPLcl9uuljR6OW3dSS3KefWpL79FNLcp9+aknu008tyX26qeVE7tNPLcl9+qkluU83uc9E7tNPLY1adlNLcp9+aknu008tyX366WPJffqpJblPN7WcyX36qSW5Tz+1JPfpp5bkPv3U0qhlN7Uk9+mnluQ+3eQ+M7lPP7Uk9+mnluQ+3dRyIffpp5bkPt30sQu5Tz+1JPfpp5ZGLbupJblPP7Uk9+mnluQ+/dSS3KefWpL7dFPLTO7TTe6TyX36qSW5Tz+1JPfpp5ZGLbupJblPP30suU8/tST36aeW5D791JLcp5daLgO5Tz+1JPfpp5bkPv3Uktynn1oatewk91kGcp9+aknu008tyX36qSW5Tz+1JPfppo8N5D791JLcp59akvv0U0tyn35qadSym1qS+/RTS3KffmpJ7tNPLcl9usl9ArlPN7WM5D791JLcp59akvv0U0tyn2762GjUsptakvv0U0tyn35qSe7TTy3JffqpJblPN7VM5D791JLcp59akvt0k/skcp9+amnUsptakvv0U0tyn35qSe7TTx9L7tNPLcl9uqmlkfv0U0tyn35qSe7TTy3JffqppVHLbmpJ7tNPLcl9usl9jNynn1qS+/RTS3Kfbmo5kvv0U0tyn2762JHcp59akvv0U0ujlt3Uktynn1qS+/RTS3KffmpJ7tNPLcl9uqnlRO7TTe4zkfv0U0tyn35qSe7TTy2NWnZTS3KffvpYcp9+aknu008tyX36qSW5Tze1nMl9+qkluU8/tST36aeW5D791NKoZS+5z0zu008tyX36qSW5Tz+1JPfpp5bkPt30sQu5Tz+1JPfpp5bkPv3Uktynn1oateymluQ+/dSS3KefWpL79FNLcp9ucp+F3KebWmZyn35qSe7TTy3JffqpJblPN31sNmrZTS3JffqpJblPP7Uk9+mnluQ+/dSS3KeXWuaB3KefWpL79FNLcp9ecp88kPv0U0ujlt3Uktynn1qS+/RTS3KffvpYcp9+aknu000tA7lPP7Uk9+mnluQ+/dSS3KefWhq17KaW5D791JLcp5vcJ5D79FNLcp9+aknu000tI7lPP7Uk9+mmj43kPv3Uktynn1oateymluQ+/dSS3KefWpL79FNLcp9+aknu000tE7lPN7lPIvfpp5bkPv3Uktynn1oateymluQ+/fSx5D791JLcp59akvv0U0tyn25qaeQ+/dSS3KefWpL79FNLcp9+amnUspfcx8h9+qkluU8/tST36aeW5D791JLcp5s+diT36aeW5D791JLcp59akvv0U0ujlt3Uktynn1qS+/RTS3KffmpJ7tNN7jOS+3RTy4ncp59akvv0U0tyn35qSe7TTR87GbXsppbkPv3Uktynn1qS+/RTS3KffmpJ7tNNLWdyn35qSe7TTy3JfbrJfWZyn35qadSym1qS+/RTS3KffmpJ7tNPH0vu008tyX26qeVC7tNPLcl9+qkluU8/tST36aeWRi27qSW5Tz+1JPfpJvdZyH36qSW5Tz+1JPfpppaZ3KefWpL7dNPHZnKffmpJ7tNPLY1adlNLcp9+aknu008tyX36qSW5Tz+1JPfppJbjMJD7dJL7nGpJ7tNPLcl9+qkluU8/tTRq2U0tyX366WPJffqpJblPP7Uk9+mnluQ+3dQykPv0U0tyn35qSe7TTy3JffqppVHLXnKfQO7TTy3JffqpJblPP7Uk9+mnluQ+3fSxkdynn1qS+/RTS3KffmpJ7tNPLY1adlNLcp9+aknu008tyX36qSW5Tze5TyT36aaWidynn1qS+/RTS3KffmpJ7tNNH5uMWnZTS3KffmpJ7tNPLcl9+qkluU8/tST36aaWRu7TTy3JffqpJblPN7mPkfv0U0ujlt3U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a3ns+fqW3+m/p/D3sc9Nj/06jBCGYfr72Ju+zmyMvenrzPOxL0dfZ8br3WaxzbHPebzN1fAw9vDBY48fPPb0wWO3lsf+/N60jB889umDxz5/7thz09f35/1Mbvo68/y+mpu+zmyMvenrzMbYd73OfP3CvPsvLLv/Qt75F5Zh2P0XBN1ftkuvMCbbek/j9HzsIrxTtHA7ePnTSHlRLOmsNfT0uUO3zx36+LlDnz536PPnDn353KHnjx26YpltraF/7t00fO7dNHzu3VSxxLbW0D/3bho+924aPvduGj73bho+924aP/duGtu5m34Np5075Ndw2rnrfQ2nnTvZ13DauTt9DaedO87XcNq5i3wNp507w9dw2rna/xpOaucK/jWctq7Kqa2rcmrrqpzauiqntq7Kqa2rcmrrqpzauiqntq7K1tZV2dq6KltbV2Vr66psbV2Vra2rsrV1Vba2rsrW1lXZ2roqj21dlce2rspjW1flsa2r8tjWVXls66o8tnVVHtu6Ko9tXZXHtq7KU1tX5amtq/LU1lV5auuqPLV1VZ7auipPbV2Vp7auylNbV+Wpravy3NZVeW7rqjy3dVWe27oqz21dlee2rspzW1flua2r8tzWVXlu66q8tHVVXtq6Ki9tXZWXtq7KS1tX5aWtq/LS1lV5aeuqvLR1VV7auirntq7Kua2rcm7rqpzbuirntq7Kua2rcm7rqpzbuirntq7Kuamrch6auirnhtbSfg2nqatybmjN69dwmroq54bWpn4Np6mrcm5oDenXcJq6KueG1nr+Gk5D6ze/htPWVbmhdZZfw2nrqtzQesiv4bR1VW5o3eLXcNq6Kje0vvBrOG1dlRtaB/g1nLauym2t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3Lba3ty22t7cttre3L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",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_random_bytes",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "private_get_name",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2111772463301017956": {
            "error_kind": "string",
            "string": "Function private_get_name can only be called statically"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQAFLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEFi40qC3IiUlA8AQECJi4AGMoYyg==",
      "debug_symbols": "5ZXBisIwEIbfJeceMsnMJNlXWRapGqVQWql1YRHffRNpotZiFxEveymd8k3/PzMZ5ijWfnnYLqpm0+7Fx+dR1O2q7Ku2CdHxVIhlV9V1tV1cfxYyPgyd+f2ubGK478uuFx+AVspC+GYd352m8I9NVfsQaXUq7nmpVMIlqgut3ASNjDTQyISZtnoCtmjdAFuSdA1/FcLK19h3SQMA3Bvtv6j6ZHP17Vz1gYxJNGv92L4jk87qGOzIvtOvtg/q1n4UsW8QAcnvUAGYVpEGsop0ekbFBGTATbi6Mx1UyKmDit2ogwD8F0e35455Cp7Me1JP45N5bioPMVcQCSBnxWm+Fwk/yU3ly7yDhanmEKcrYMjONMdoTrNoUPJjOPjgfBmDJz3uJeI/OespRN9lV5XL2g8bbnNoVlcLr//Z+dHu23Xtyq8PnY9b8LIAIW4Q5QqN53EIgaZCm6ARdH4B",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "set_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          }
        },
        "parameters": [
          {
            "name": "minter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "approve",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "set_minter"
      ]
    },
    {
      "name": "_finalize_transfer_to_private_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finalize_transfer_to_private_unsafe"
      ]
    },
    {
      "name": "prepare_private_balance_increase",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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HDlD8+vIkTO0v47IGdpfR+QM7a8jQaMDNHLTopHzBeokB0dTzwXqZAH61PMU0q+t83QH70Ydd1+DOn69BnUceAXqgqeuQR2XXIM6vrcGdZxsDeoC9QrU8aY1qONNa1DHm9agjjetQR1vWoG6x5vWoI43rUEdb1qDOt60BnWBegXqeNMa1PGmNajjTWtQx5vWoI43rUA94E1rUMeb1qCONz2AupnmiVz+WXjiLuBNa1AXqFegjjetQR1vesTVNPuFug0F6njTGtTxpjU6R7xpBeoRb1qDOt60BnW8aQ3qeNMa1AXqFajjTWtQx5vWoI43rUEdb1qDOt60AvWEN61BHW9agzretAZ1vGkN6gL1CtTxpjWo401rUMeb1qCON61BHW9agXrGm9agjjetQR1vWoM63rTCc45ZoF6BOt60BnW8aQ3qeNMKz/RmvGkN6njTz3eObsKb1qCON61BHW9agzretAZ1gXoF6njTGtTxpjWo401rUMeb1qCON61A3eBNa1DHm9agjjetQR1vWoO6QL0CdbxpDep40xrU8aY1qONNa1DHm1agbvGmNajjTWtQx5vWoI43/fwTd84K1CtQx5vWoI43rUEdb/r5p0udxZvWoI43rdA5OrxpDep40xrU8aY1qONNa1AXqFegjjetQR1vWoM63rQGdbxpDep40wrUBW9agzretAZ1vGkN6njTGtQF6hWo401rUMeb1qCON61BHW9agzretAJ1jzetQR1vWoM63rTCs18eb1qDukC9AnW8aQ3qeNMKzzl6vGkN6njTGp0j3rQC9YA3rUEdb1qDOt60BnW8aQ3qAvUK1PGmNajjTWtQx5vWoI43rUEdb1qBesSb1qCON61BHW9agzretAZ1gXoF6njTGtTxpjWo401rUMeb1qCON61APeFNKzyFlPCmNajjTWtQx5vWoC5Q//wTdwlvWoM63rRG54g3rUEdb1qDOt60AvWMN61BHW9agzretAZ1vGkN6gL1CtTxpjWo401rUMeb1qCON61BHW/6eeoy4U1rUMeb1qCON61BHW9ag7pAvQJ1vGkN6njTGtTxpp9/HkYmvGkN6njTCtQN3rQGdbzp55/9EoM3rUEdb1qhczQC9QrU8aY1qONNa1DHm9agjjetQR1vWoG6xZvWoI43rUEdb1qDOt60BnWBegXqeNMa1PGmNajjTWtQx5vW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8LTDChiedlgBw9MOK2DofItXpTzwN9w2wND5roCh810BQ+e7AkYAUwZD5rsChsx3BQyZ7woYOt9i55sH/obbczB8w20NDE87rIDhaYcVMHS+5avSwN9w2wBD57sChs53BQyd7woYnnZYAUPmWwbDN9zWwJD5roCh8y13vgN/w20DjACmDIanHVbA8LTDChg635WrEp3vChg63zIYvuG2BobOdwUMTzusgCHzXQEjgCmDIfNdAUPnW+58B/6G2wYYnnZYAcPTDmUwfMNtDQydb/mqNPA33DbA0PmugBHAlMHQ+a6A4WmHFTBkvitgyHxXwJD5lsEM/A23553vwN9w2wDD0w4rYHjaYQWMAKYMhs535apE57sChs53BQyd7woYOt8yGL7htgaGzHcFDJnvChgy3xUwQudb7HwH/obbBhiedlgBw9MOK2B42mEFDJ1v+ao08DfcNsDQ+a6AofNdAUPnuwJGAFMGQ+a7AobMdwUMme8KGDrfcuc78DfcnoPhG25rYHjaYQUMTzusgKHzLV+VBv6G2wYYOt8VMHS+K2DofFfA8LTDChgy3zIYvuG2BobMdwUMnW+58x34G24bYAQwZTA87bAChqcdVsDQ+a5cleh8V8DQ+ZbAyMQ33NbA0PmugOFphxUwZL4rYAQwZTBkvitg6HxLne8FDM/5roDhaYcVMDztUAbDN9zWwND5lq9KA3/DbQMMne8KGAFMGQyd7woYnnZYAUPmuwKGzHcFDJlvGczA33B73vkO/A23DTA87bAChqcdVsAIYMpg6HxXrkp0vitg6HxXwND5roCh8y2D4Rtua2DIfFfAkPmugCHzXQEjdL7Fznfgb7htgOFphxUwPO2wAoanHVbA0PmWr0p8w22lYgb+htsGGDLfFTBkvitgBDBlMGS+K1clOt+ViqHzXQFD57sChud8y2D4htsaGDLf8lVp4G+4bYAh810BI4Apgxm28xXr5zmLjY9gOup846X5mKcxZbkHcz3WjprZmMIyjRTT47F21J9uHmtHLefWsfb0PbTNY+2oMdw81o56vc1j7ah92zxWGehYO2qyNo+1p75p61gH6pt6+k7X5rEO1Df19DWtzWMdqG/q6ZtXm8c6UN/U05epNo91oL6pp+9HbR7rQH1TT1952jzWgfqmnr7FtHmsHfVNOU3zxjnJYxbe0xeTcvLzX87Z+PtjLWwsEueNvbnN2YRfd0R6+mSSuRzNfPvn8m+fH+tAhjrajjqtF462o17rhaPtqNt64Wg76rdeONqOOq7to+3pK0AvHG1HXdcLR9tR3/XC0Q7VS/X0ZZ0XjnaoXqqnb+C8cLRD9VI9fa3mhaMdqZcyPX1X5oWjHamXMj19AeaFox2plzKTDHW0I/VSpqevqrxwtCP1Uqan75+8cLRD9VI9fankhaMdqpfq6ZsiLxztUL1UT1//eOFoh+qlevpOxwtHO1Qv1dMXNV442qF6qZ6+ffHC0Q7VS/X0lYoXjnaoXqqn70m8cLRD9VI9ffnhhaMdqpfq6RsNLxztUL1UT19TeOFoh+qlevruwQtHO1Qv1dMXCl442qF6qZ6+JfDC0Q7VS/X01v8XjnaoXqqn9/O/cLRD9VI9vUn/haMdqpfq6Z33LxztUL1UT2+nf+Foh+qlenqP/AtHO1Qv1dMb31842qF6qZ7ezf7C0Q7VS/X0FvUXjnaoXqqn952/cLRD9VI9vfP8haMdqpfq6b3nLxztUL1UT+8+f+Foh+qlenr/+QtHO1Qv1dM70F842qF6qZ7eg/7C0Q7VS/X0LvQXjnaoXqqn96G/cLRD9VI9vRP9haMdqpfq6b3oLxztUL1UT+9Gf+Foh+qleno/+gtHO1Qv1dM70l842qF6qaHee26Geu+5Geq952ao956bod57boZ677kZ6r3nZqj3npuh3ntuhnrvuRnqvedmqPeem6Hee26Geu+5Geq952ao957bod57bod677kd6r3ndqj3nttJhjrakXopO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO9d5zO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO9d5zO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO9d5zO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO9d5zO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO9d5zO9R7z+1Q7z23Q7333A713nM71HvP7VDvPbdDvffcDvXeczvUe8/tUO89t0O999wO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dfF7Ns1c675mE5q5fn3Ppplr0vdsmrnOfM+mmWvH92yauR58z6aZc/z3bD583vZ2DkO8pI3ztpmSm//y5d/+z1lIiCeeezrx3PN55x5ty3PPy1N+l38H8+e5+6bnvkzDmGkKf5570+eZjbk3fZ7ZmPunzzN+udok2Zx7zP62Vs3D3PN5556mE8/dnHjutuW5P782JXfiucuJ5+5PPPemz+/P+5nc9Hnm+XU1N32e2Zh70+eZjbkfep753oM/fA/h8D3Ew/eQDt+DQveXZe4VvJOt5zQu92rmwrtY3NvG6d1IOWn8pLPW1M15p27PO3V33qnLeafuzzv1cN6px/NOPZ136ue9mprzXk3Nea+m5rxXU3Peq6nGD2xrTf28V1Nz3qupOe/V1Jz3amrauZp+Tce2c4X8nk47V73v6bRzJfueTjtXp+/ptHPF+Z5OO1eR7+m0c2X4nk47Z/vv6bRzBv+eTltnZdfWWdm1dVZ2bZ2VXVtnZdfWWdm1dVZ2bZ2VXVtnZdfWWdm1dVaWts7K0tZZWdo6K0tbZ2Vp66wsbZ2Vpa2zsrR1Vpa2zsrS1lnZt3VW9m2dlX1bZ2Xf1lnZt3VW9m2dlX1bZ2Xf1lnZt3VW9m2dlUNbZ+XQ1lk5tHVWDm2dlUNbZ+XQ1lk5tHVWDm2dlUNbZ+XQ1lk5tnVWjm2dlWNbZ+XY1lk5tnVWjm2dlWNbZ+XY1lk5tnVWjm2dlVNbZ+XU1lk5tXVWTm2dlVNbZ+XU1lk5tXVWTm2dlVNbZ+XU1lk5t3VWzm2dlXNbZ+Xc1lk5t3VWzm2dlXNbZ+Xc1lk5t3VWbui3tJfp5IZ+H/s9nabOyrmh37F+T6eps3Kemjor54Z+Q/o9nabOyrmh33p+T6eps3Ju6DeZX9Np6HeW39Np66zc0O8hv6fT1lm5od8tfk+nrbNyQ78v/J5OW2flhn4H+D2dts7Kbf22L7f1277c1m/7clu/7ctt/bYvt/XbvtzWb/tyW7/ty239ti+39du+3NZv+3Jbv+3Lbf22L7f1277c1m/7clu/7ctt/bYvt/XbvtzWb/tyW7/ty239ti+39du+3NZv+3Jbv+3Lbf22L7f1277c1m/7clu/7ctt/bYvt/XbvtzWb/tyW7/ty239ti+39du+3NZv+3Jbv+3Lbf22L7f1277c1m/7clu/7ctt/bYvt/XbvtzWb/ty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ux7oKJ3RCN+tuh7oKJ3RCF8Nuh7oKJ3RCN9suR7oKJ3RCN/6uB7oKJ3RCN+IuB7oKJ3RCN8WuB7oKJ3RCO+kvx7oKJ3RCO8yvx7oKJ3RKO/A9qO8A9uP8g5sP8o7sP0o78D2o7wD24/yDmw/yjuw/SjvwPajvAPbj/IObD/KO7D9KO/A9qO8A9uP8g5sP8o7sP0o78D2o7wD24/yDmw/yjuw/SjvwPZtv9LSLAdq428Hep17Oz3AdT7tXKqv82nninqdTzsXvut82rk+fc+nodfiXefTztn+Op92zlXX+bTjKq/zkcbm09j5uaEXoF3n09j5uaHXiV3n09j5uaGXc13n09j5uaFXXV3n09j5uaEXR13n09j5uaHXMF3n09j5uaGXGl3n09b5OTT0iqDrfNo6P4eGXrhznU9b5+cwtXV+Dg29ZeY6n7bOz6Ghd7Zc59PW+Tk09AaU7/k09KKS63waOz839NqP63waOz839BKN63waOz839EqK63waOz839IKH63waOz839LqE63waOz839PKB63waOz839FP+63waOz839MP463waOz839DPz63waOz839KPt63waOz839BPo63waOz839IPi63waOz839PPc63waOz839GPX63waOz839NPR63waOz839EPM63waOz839LPG63w+fH6WFO08nzy5x/mET89nus3HmPv5PG6cJvm1bXJ52dQWt80p/No259+3vR5nHOQ40yDHmcc4zk//QLDacZpBjtMOcpxukOOUQY7TD3Kcg/RDfpB+yA/SD/lB+qHQTT8U5m3NNNnCgXbTEG0daDcd0daBdtMSbR2ojHKg3TRFWwd6aFd03UU8fhfp+F3kw3cRp+N3YY7fhT1+F+74Xcjxu/DH7+L41R2PX93x+NUdj1/d6fjVnY5f3en41Z2OX93p+NWdjl/d6fjVnY5f3en41Z2OX935+NWdj1/d+fjVnY9f3fn41Z2PX935+NWdj1/d+fjVnQ9f3XGajt+FOX4X9vhduON3Icfvwh+/i3D8LuLxu0jH7+L41W2OX93m+NVtjl/d5vjVbY5f3eb41W2OX93m+NVtjl/d5vjVbY9f3fb41W2PX932+NVtj1/d9vjVbY9f3fb41W2PX932+NXtjl/d7vjV7Y5f3e741e2OX93u+NXtjl/d7vjV7Y5f3e741S3Hr245fnXL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",
      "brillig_names": [
        "discover_new_notes",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_random_bytes",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "is_minter",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          }
        },
        "parameters": [
          {
            "name": "minter",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_minter"
      ]
    },
    {
      "name": "finalize_transfer_to_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "finalize_transfer_to_private"
      ]
    },
    {
      "name": "owner_of",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "5Z3bbts4EIbfxde+IGc4HLKvUiyCJE0DA0YcOMkCiyDvvpJrHWzRYkWwKg83QVVzPP/Hw5AUR/Ln5sfTw8fz3e7l5+Ft8+3752Z/eLx/3x1emqvPr+3m4bjb73fPd+P/3oj2jwQ8Gby93r+012/v98f3zTepjBDbzdPLj/bfFqn5kp+7/VNzhfC1nZYXAF1xoWAoDdZRWmlF59JKk+pLG3QUNsrYc2FDgsaF/9k2+k0c/bZzIqW0K+rHSPVPpq9/46t/ScxdaY04r98Sd7BWS3OtX8nY+iVc6j95sWt4IeX2Ilj2XoRFjxduipyLc9OvPLULSne1C9pe1y7Z31F0yd3aaRVoF+iPOczOgNMOWPcdFNgMna4dbI5m1TgM3lHz8K9KNLyCE7sGidV/3gkIsYYTtYYTu4ITuQaJNCs4gShdWJo+xoKiCyfT0kTcldZGjiJyG8unkbUXwmaYdaWRJ/ko8pZvspavdNbySfrlG4E++TisIvWlE4cg0p18JuNZJzAO8pXQ84UbHbpfFzWa8GpZAcR/gbZfe7EWnjUzcbebGFcMKnVSryFr9VnXPf9W3dNYfWtmRJgZuc2MEoPZCD9o2rNiDSerkNg/7wQFruGEV3AiYQ0na5CAXMNJlC78t2Z4RMxavpJ5y7dZy79xZ+hSPtsylodKuYeK6e5USTus4xH0LxtebkMQYBPgRwf40QF+WAbY0HKbG6upeRt3D6bOBgRc2Dj6mO3verMddRowrnvM2H+zAjGUdY0LkFZ1KmA0UJ2FCbrvJeBx0ROkqQDSYg2QFbQkiQpakkQNLXljK1EYZA0tCTWMSbAVQKKqAFKJQiD7HQlpOYEspSVnIUsZk3OQVEp07cvqy6ItJJfSXWchS1kMzEGaGrprMZvmOchiNs2zkBW0pBalbLVmIWtoSVnBmNSylGXdHCSoCiCxlK3WLCTVAJnlmGyVqyxD5kl5ljNaq5yyXHCclOtclWuZrfIsA+hJebZRMc8bLifl2UZFk21UvPE4UAbKbbZR0eYaFVlkueo/Kc919meZbZ3LbPs5JhwVAQflo7TPs3JKuM5ZdhmfwKMHrZcWPmEmvDxbgin1kGauzfUJIeuE+2FETC6k03owTcKRPCamKgSTuc8hZjuJtKaUEDSPmfJZYUzMUiLtLKYRCW+aYmKWMqF4MKsIQUZWMaGYlA9HI2KmnFMcE7OOCQXrmFBSPgmOiVlHCEr54DgmZh0hKOU06kWYVvavjbQwwUz5FDgiJiccglD0KlCqa+Up3/fwKM+2zlPets8qtyln7nqUZ1vnKT+Y6lGe8PElWOiVC/IEf9HPFFJoc40JCd8hj4mZ8EyxCFPi8JIkuj4IsJjwcIuImfJTpzExE94Cx8RMeC20DFNTj2kmIYhL6bRq9NJzMWnNlJMhY2ImnDkZETPlNMuYmKUs9gj6SEskrjFTTuCMiVlFa0ohSgm1Ps5SFggezpSzN2NyQimTio8z5ZzWiJyY8HFAVM5S1nwezpQP66JyFjM++3fmS7Iw4Uw5Qz0mpy5lh+3jLCYOzXNyMXHIw1lJHDLFbD89nJXEW6sK4cQhPwJRTjlL2X/Oc8qU3wcdlbOUeOvhlKXEWx9nKfHWx1lJHCrmsN7HWUl7FnN/yMdZybyiKplXism/QNX/zCHqyX0wScW0p4ezlPsmHk5dTLz1cBYzf85zFpNS4+EsJtnEx1lKfsJsUk2zXaki463hLGV8znNCyu8ii8qZ5bxyku5OS+T+hz9Z4cTGfXvTqs6RpYmfG7/C7LHh5TbuW1geG/eyffYBAYk3HoTwWakgKxtihUG+MMiXCvKlgnxRkC8d1F46zFcQ143jS58Vh1jdOFrzWQWNFPe0Phtj0D1FWtG9WM+Cw2Z5XFLuUTzrR4EKsDHLbdwP53hs9PI6UDLAJsCPe9x6bALaVAf40QF+3OPVUtevLcPUxiy3MQF+3JnbHhu92IaEDLAJ8ON+xeqofVw2tLhNCUSATYAfxAAbs9xGLR8LRDLAZnk8IPfPnHtslq8JiQP8cACPCeg7JqB9zMJ+8NVc/Xt/3N0/7J/eGov2w4+Xx/fd4eV8+f7fa/fJw3G33++e716Ph8enHx/Hp7v94bH9bCPOf76jFNvm9nerpb3UtGXRXrTdBpC2gNz4bPz+Dw==",
      "brillig_names": [
        "owner_of"
      ]
    },
    {
      "name": "get_private_nfts",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "page_index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_private_nfts"
      ]
    },
    {
      "name": "transfer_in_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7V3Zbhw7Dv0XP/tBFLXeX7kYBFl8AwOGHTjJAIMg/z7Vjquq7WKXbhO0m4L4ErhjHYs8RwtFLf3r6svNp59fP9ze//Pw/eqvv39d3T18/vjj9uF++vTr9/XVp8fbu7vbrx+O//vKHf6BGp8A3799vD98/v7j4+OPq78gFOeur27uvxx+rhinP/LP7d3N9An97+tteef9XNwFv5b2lSgdUojPpUOKYSldkChcQqnPhUt08bjwf66vvHMy9te5EgCo72m/EP+xLPyXFv8Qc55LJ8R9+2vMs7M1QXltP6C0/eBf2n+oxcO71JKoWkJ1MKtdj9rGQfht4QJzFaH41GgaMaalaWR4TS2STk/NCRdznNs3p4a5glrWv++nug4VxED7i4sLtZb9Cg7tB9e2dNQZUnpjemKVsP64J9S0b30EP7eECMHtW38YB4/GxISv7U/Yuf2lb/tz5/znzvkvnfNf4f3tL6v9NW0MqroMQncBhaNfDcr7Cqc6l81unbe8L3+MLx0bDxLMB1hi4hQCNoxHXJoCxobxucJifc2pGbbt90SEPJK33g/l7VDa4lDa4lDahtitt0/m167NF1nrXtD8otz8sizVHba6ypR/mP+0z3k1Gxxld4E0J6CKd2v+xRcyN1f8kh4puOZ4MD3lPDAlI1KEyOyMSBkitc8L3RCpfYbqhciiPS7rhUiRFJERORFpXVuEyOC0J4b0EOnyQqR3WyItIJchErSnPLoh0mZtGSLVJ1i7IdJapAyR6tPC3RBp2R8ZIoNlf4SItOyPEJG2RJQhUv1OSTdE2hJRhshkSQshIi0glyEyW0AuROTAAbmHlcjoG0Tmutw5ybViozQuJ+fDEemeMsNDDbPRHvxx4YNAdeAhoweBoht4KOpDIBvidAsEA+cy+hBo4BxJFwJ560HKBQomkG6BBs4VdSHQyFtwfQhkYbZugUbeMuxDoGAC6RZo4C3OLgSKA29U9SGQZbN1C5QszFYukIXZugUa+V5mHwJZNlu5QBZm6xaoWJitXCDLZusWqFqYrVwgC7NVC5TcwFf7+xDIwmzlAlmYrVsgCCaQaoHQBLq0QB5XgUJ8LVC0MPvSAuWFPZ+PvupiFsj2g3QLlCzMVi6QhdnKBbIwW7dA2bLZygWyIEG3QMXCbOUCWQ/SLdDID9X2IZBEmO1rWgWKDYGgpoWY6eejL5Uki4s+C5GdG8vdMJa7dSh3YSx1YSx1/VjqilxU7cddkWufHbmbh3I3wFjupqHcjWMFkXGsJULsOcw4OCDyquVFHeg5FDg4kNVP7j0cQ8lVfUPug0b13akHGouzTi1Co/pYsQsaQf0Kow8arTVK0OjVr4j6oDEYjRI0WsAjQaP+FGUfNNoUI0FjsClGhEb1ybw+aFSfJOyCxmgZHhEaLeCRoDFZwCNCowU8EjRmy/CI0GgBjwiNFvBI0FiC0ShBowU8EjRWC3hEaFR/uK0HGquzgEeERgt4JGgEyzdK0OitNf47GncffKn6T9j2cNutRptiRGi0Ti1Co62pJWjUf965DxptFSNBo6VtZWi0gEeCxmKtUYRGC3hEaBR5Miyur4FEbPACGfNSPAeX94ujw/luGLojGgs+2S9yk+Jy9oNz2LsDvSsAvSsAuXMHvO/dgd4VwN4VkPlK6As6IPI+wUUdiJ07IPKGwEUd6F6BvoNRcKn3UCL1Hszl3iey3HsoUXqfyErvw2jtfSKrQb0DdTYF4SgDQ75oWnDxtmAivNU/5sp5Cx3kOyS9HUrbDjIpkt4OpW0HORpJb4fSFofqt6h/lVlx8fbo4Bnp7ZT+jbO708+lbPwNYTB/B9M3dtB7Rf3tYGyW9LeDpJKov1m9v35dvvoILX+Tc4u/ycPWX/UZH1/n0oiQmv5mXP2teeOv/gSRL271N7f8zcUv/hYft/6qzyfJ+qs//STsbxjMX/Xxlai/3o2lrwf1W+my/vqx5iPvB9MXB9NX/1EYWX/1n5wR9neseNLrP5cj7G8YzF/1+RxZf/Xnc077+8cB/QmLfQf0HxJqOKD/1gauKcHQTBlNTWq5WAO+uo2/+pfYwv6qHxJF/UX9h0KE/R1M30vcUEm42JTTy7t9Tzb5qM+mS2zEN226QFvNDhabMsDGppD02XSJZcoLm14W/2PTpbUjbEqX1o6wqdizH09eNi8To5vLTmm1cFz4iUeROM14xGrtUYLHKcwxHiV4BHuVVIZHa48iPHprjzI82pM+/45HX/3Co4sbHtHe9JHh0R71keHR4kcRHoO9YyjDo8U9IjzaY7lCPNo8I8JjshfZZXi09ijCYw7GowCP0UnwGGDN0U+R1D4xEXFO0UeMjTM2uZbZ1eJw3Z2EQ2p/6+y0WzM7m/NqNrjQ7co9umoK6VYIrA8pV0jmSQNT6A0VyqaQboXQ+pB2hawPKVdI5gKLKfR26yGZ82am0NspJHP6zhR6Q4WCKaRcoWIK6VYoWbStXSGLFJQrlC1S0K5QNIV0K1SsD2lXyPaHdCuUHBkpxImNmUUX0rFCTyh6V6mFonc6Wig6txsB5quhETA32pBLy2OAE25VLpMXSZdGAUeNE316tifrsofO213QnqTLnqiMn6iMn6SMH/oU0gXtqbrsoU8XXdCe8t72LLOfd/6FPe85r0INsxUe/GZerdVY2bCSXTBWCFasBxGsgDdWCFaysbJlxVtboVhJxsqWFXTGCsGKzcwUKzYzE6wEG20pVmy0JVh5/+xLF6xEY4VgxdbMBCvJZmaKFZuZCVayzcwUK7ZmJlgpNjNTrNjMTLBSbc1MsWIzM8WKzcxbVgr9tvjwrNjMTLACNjNTrFh+hWAFx2wrHldWwuZUWwljZhLyclLSZ8QNK3HMeKXFypjxSoOVNGYmocXKmHNQg5U85uqwxYqNthQrNjMTrBRrKxQrNjMTrFSBmXnidmblOHymWYkxz6VTOVqCAEaKl5RnWsr6yMi0fHuyvjrXtfWlZ+slVtCXs96fWOmmsFh/9J1vJ6zH5SrZhHtRB2FPTLP1OR569XNp+ioZrtYH1/yqOkxuMQSPRo/nr6qrPrec9Q6OnX1CnboqtY8KjoWiN0o8ugUVW40J/TI4Y6gNOYrz858uLviGHGX503mKxFpyhLS2iwibbw6sacxdof0Xo+qgcX+LFWsrBCtlzP2PFitjRrgNVqq1FYoVaysbVrxzY+Ypd2/1T6yMua/aYGXQfdUWK2PGKy1WxsxTNljxY87MLVZstCVYGfVkQoOVMXcQG6wEaysEK3HM/Mo+K3BiXPFpyTvmLSaejzmRFt3HMOqJjHoip556PiYx6skMf3I6H1MY7aDQM/WSjI8JNpgKDEw6G+NP7Iwtx//S5vTfhAkMTD0fA4x6gFGPZ9Tjy/kYZNSDDH9OjAe7mMhoByfeFNvFnHj3axdD94X9HesJRbIAaZ2aUtn0B6RPzLdQ9Bq/iUoclCeVgpznIQhyjVtUZKEqB4XIQmUOio7hmigWG5HFfOTVxWI+sZhPLOYzi/nMYiOz2CgsNujXY6cJeY4Pp33yLapmBirQoyG49e1Zl8oWFVko2i/ANVSPm9Em0LdYWyj6PmMLRd/3a6ICjUrLV5NC2bAR6fzjFH4vJySCgy2qclB0/qqJyhwUvU6BuJ55iNFtUYmDCqy66FsSLRR9i6CFor+juYnKHBR9C76JKhzUiZGthWLVVU/4lZeRbSryGpWcY6EiBwXIQhUOyrPY8ImDQhaH9IphSmAsKMTNuJFCYKEKBxU9C5U4qBMjQAvFYiOxmM+sujKL+cJivrCYPzGbY8gLKrktKjFQ+cSqrYUqHBQEFqpyUCdigAbqRAywHzlkjCwUJyLKgVNXodeweTldm8MmC1Do99FqmJtujZuovNDrvAYmMDDlfAx9Q64R+5+4QdZCZWChWHUVVl2FVVdl1VU5dVXnWShWXQAsVGShKgd1YiXUQmUOij6WvjtaVHodVN2cnZwc2GDoVdBuL650L96vJzFso3dFGpjAwJw/kp04m9vAMOqpZ88A6BwwMIx6gFEP3V9rnNt1zX6DoXPGDQyjHjrz28CU8zGBUU9g1EOvVI70oTD5fE2TZ2AY9dDZ131McQwMoy9UZGDOHg8QXGBg6vkYYNQDDH+8Z2DO1wfwzHbwe/r034+Ptx8/3d18nxCHX/68//zj9uH++eOP/32bf/Pp8fbu7vbrh2+PD59vvvx8vPlw9/D58Lsr9/zP3wngOqGfbIHDR6z1Orhw+HgYRGNw1zH4qdap5v8D",
      "brillig_names": [
        "transfer_in_public"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "transfer_to_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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fPm3/3MWEuKJ5z6feO7pvHOPtuW5p/Upv8u/g/nz3H3Tc1+nYcw0hT/PvenzzMbcmz7PbMy99nnGr1ebWTbnHpO/rVXzMPd03rnP04nnbk48d9vy3J9fm2Z34rnLiefuTzz3ps/vz/uZ1PR55vl1NTV9ntmYe9PnmY25H3qe+f4Gf/g3hMO/IR7+DfPh36DQ/SVZegXvZOs5jcu9mqXwLhb39uH53Uh51vhJ56embs47dXveqbvzTl3OO3V/3qmH8049nnfq83mnft6rqTnv1dSc92pqzns1Nee9mmr8wPZTUz/v1dSc92pqzns1Nee9mpp2rqZf07HtXCG/p9POVe97Ou1cyb6n087V6Xs67VxxvqfTzlXkezrtXBm+p9PO2f57Ou2cwb+n09ZZ2bV1VnZtnZVdW2dl19ZZ2bV1VnZtnZVdW2dl19ZZ2bV1VnZtnZWlrbOytHVWlrbOytLWWVnaOitLW2dlaeusLG2dlaWts7K0dVb2bZ2VfVtnZd/WWdm3dVb2bZ2VfVtnZd/WWdm3dVb2bZ2VfVtn5dDWWTm0dVYObZ2VQ1tn5dDWWTm0dVYObZ2VQ1tn5dDWWTm0dVaObZ2VY1tn5djWWTm2dVaObZ2VY1tn5djWWTm2dVaObZ2VY1tn5bmts/Lc1ll5buusPLd1Vp7bOivPbZ2V57bOynNbZ+W5rbPy3NZZObV1Vk5tnZVTW2fl1NZZObV1Vk5tnZVTW2fl1NZZObV1Vm7ot7SX6aSGfh/7PZ2mzsqpod+xfk+nqbNympo6K6eGfkP6PZ2mzsqpod96fk+nqbNyaug3mV/Taeh3lt/Taeus3NDvIb+n09ZZuaHfLX5Pp62zckO/L/yeTltn5YZ+B/g9nbbOym39ti+19du+1NZv+1Jbv+1Lbf22L7X1277U1m/7Ulu/7Utt/bYvtfXbvtTWb/tSW7/tS239ti+19du+1NZv+1Jbv+1Lbf22L7X1277U1m/7Ulu/7Utt/bYvtfXbvtTWb/tSW7/tS239ti+19du+1NZv+1Jbv+1Lbf22L7X1277U1m/7Ulu/7Utt/bYvtfXbvtTWb/tSW7/tS239ti+19du+1NZv+1Jbv+1Lbf22L7X1277U1m/7Ulu/7Utt/bYvtfXbvtTWb/tSW7/tS239ti+19du+1NZv+1Jbv+1Lbf22L7X1277U1m/7Ulu/7Utt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",
      "brillig_names": [
        "discover_new_notes",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_random_bytes",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAABEkUUvn1\n/ikrvcra2npzWTBCih28DlMJhcpvfp2FB9AWmnEdIL1FdfM7s9nrvFTuIrMC7ZXkE2HLjTRI1XIt\n3g3wfQOK3mgHkOawguwn6Y1tC5lc7IXVReER4pvx2r4xI8yIHceukdBRZ8qodt1Xu4QhrsqCVplw\nITeo/xDd9/sa2gZ45eyEgCAYK62Qz5ojnzr5dfre/9q7OvazXIcCSgecDtluk/SWCUgezq5h5N4O\nJfBj8Hc6GY9f0HkMPvDTB8V/oFetPo9xycJNIsannODt29CNaGZz+9cmPxhiKpQSINjS4rPOPUVW\njnZRCH7m3Ptc9SFpziaaCoGg+v3GoSE+QsgX5W+29LfCseuuXFOKdXoM0rvFjprgWS+POQ4tIK48\nUtc44k/qz3K3qc5Pc2jsQLaoyTsKmuyNDiX3PrMX1iOsyk0NZe9dF22nIFaVTwmQEpWynu2mWMKf\n1iqp/itUgVALWSzYSNgI+QRKejRgBJsOvfFjchDu/cpgHxAoBFa7cBtbC0Y7vPDE/nGQVSOT0JUz\n4bIAS9hOn4pTqI8DgPTmuzBHdr/U+yLiCYd0FWSB6aP48JHTDbEAOm2qtAgsZKbaJw9p1+cbqbhm\no1/hIMFBKUIklmmIy3sciHHxFxpsATFPP+jmqDzi1vnGRtyfM/qiZS3QdNUGEU7gbUMq0PSFsQnq\nSSZYq2xLXKRu0CjIBfMHJ3/mvqbMHc84ZQCQzf+9OyogrnGqi545Zhi2LsedTFTVkFaJdqDFb9Lx\nEUYjM+r0+K9y/OB3menL5KklMmS7kIUWjkQrWJx1PsMoBD1EVZ3BZUaL/0uk9Z7sLSzUjHWu/EIQ\nozQ+WJKoMCp273Twf+ztALgFqWPrm4qv2SP7TzUzrN+00i1NQRykHqKgu2OAYTkOh/4g04zOwKIR\n6Ap2KZ4/kWPWhmvynSQHBgaLmRqRUZRG/FKuxHucqmhiUccFP70lX+T1KM6rig6FJe8d6UmjSnRH\n8cNod4DfD8hhh8LCjnOyeQ5m/J4BKCqLs0XGPB4YwJyVhdJP8sNrg3DqX1AKLFSisfc1nAcXV8tI\nZJpbEXWw6ql6jJDqzk+Pp1/WfNgovcWLYt3ury7evSlEGvXAi70WFzuAfEkL2YTT1S5xgWlf3HVS\nQAQ/KvH1RauHiw7PeKgD7Itu+7Btc58hids4bFjTrsLSjkcRv/EZAq5eDpdAOop+Jypu2G66g7Mc\nbHHPCmh6YnIMdi19C3MBJEyYZ0dcc6tbRSqFBc4fFokr/LYUKGjBBvYpG0Hi9dIjh/TlfVRt1mQ8\nX4eP7WTimGL09xd3Kwhdz9gceozIwAX9O4lgBdQIx0fwwfy2cAQj/thfWfyAc0cFyyKn+aI1D3Ed\nLPZzs/0/64BbbscA0zQQsh1V/R0IrQOkDK+ZzWMOjgnxGJJy0xGUqun+moue4/zuyKl0LxCzgvwb\nB9RTgFgY/b2VtS4ylvtzW8Gr7oouQyYKSaCQldpdTSoUXgtO68mggscM1Fjmr7t9swcmKhRSHLDh\nKyJmCuo3E63xMuWbcBgHrX71z3rh4sSN94nINQCJI2T5rWUHgHMp8ROUwA9JqFtMAKI8WKrXt7q3\nUTFNhUhQkadRr5YxUxrYIpsqGzLZ12muqGjG95SHjAIWSkShgRLyKM1Fqw5rLD1VsXPsHDaFaf40\n8gi9Jeo6eYuU1eY1Bsg3XZck420ETXhkR/G+gDnanoh5OpZyWhGoZGP/v4ang+LIDWoqhSQPU/vb\nmsIvprEhBMiS4J29tUDxhVocDns2efiV4H9TAFTsMzdy0lvPW0L/+NkPvufAfzBUdlpblh3r9G+Z\nkmkJvGcPWVz7vHvQIf8OWL3I0x9T4YasXKwd2oxkIjM+IAtaDT7C5fKzBDrVkn917iJOe4uwdsAd\nnRXmldtJYoR5L0k+SqJepx+Q/5V+KqqeomSYTxXLfqssT2ml2Ailb00MDfwyFqfkTkJc7/GGGfQr\nfw/rg2SOEbH+DYvGtgxvIQt+Bww1reRIgasMq+ppQb4/zeTE4IFhvnl5SCKu+7P2F0xNqsxv6+gt\niDGpBETvEX32GkvxinRGtU2OzdDlJyENPQ9wXJw7Qm4veGR5CujPFMTyBusHozGX/1z2u6wLrwcD\nm+cLVXtvDU1Z+xKAoZlYPQqQ5tVT5L1kSbWO9QehChGFSw0wrqddreiukl/tbL8F77PitlsEveca\nM00v6zMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAACI0/Bx6/BkMJAU7VYrBY7z/E1DWAUymCZstQRNUjiKIII650zdewGCRlEqALo\n3R6B2kgUMn7fMxqutLU5yPCBvQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04s\nAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJ\niS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "transfer_to_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "4718290446670665014": {
            "error_kind": "string",
            "string": "NFT not found when transferring to public"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3briw7biX6L/W8H3Shbv0rDcOwvX0aBRSqGrb7AAdG//vJmTkjMtdKKTVTSSkU4vCDMdeuUJIaHJRIhhj677/8+e//+n/+1z//9e//zz/+8y//43/+91/+9o9/+5f/+us//n7513//Rdvrf/vP//0vf//653/+17/8x3/95X8YiumPv/z73/+8/Okc/d8//vL//PVv//6X/6Gt+b9/PD9tlN+eNiben1aUezrGsD2dvKo8rV3S2+OXv+39eRNT7nnv4va4D2F/2iqfe9p6uz1NWv3y9D/98RdNAKcMjgM4ZXD89OA4uoPjYwUco82uiyb3ITgB4JTBiQCnDE7Kg2PsHRxXAYe0c99Pk056fzqaLwlGdZegcxI0RaX2mSdbk3H5r3p73Dp/f9pk1zZl7b4WKvtAoJjlj1W0/frl76B+n4I5/xSycY92lnb+Ofoi9MMUvoZRdpgOap/K5e+7T7icCyXaPCLFOztM0FcJrrsE311C6C4hFiTsgy5/p/RagraR9qXMpninoM+uTcnrza8vf3/R7tXj0exPR+NMZZkMibanL3rbytMXd9kWGPMQ12RXd5PM3Q/c64e11WYHxOrKw0qn3SEf9wG6WijBQnNbyCpYaHILaVjohxYKO44mWFsBPYQdv5DcRxYysNDkFrIsFkr7CqBJuVix0CUS3lWi+BCrFh4P8Z71RFULbYPeI9sQatmddPMTzC/Z/A7ml2x+fwLzR033x8m8Nr/199LS/VHtwnW64QzTdfdfjw8ky073UpR36aEq734r49gobsZpuRlflh26O3z4vWBKStyM9cEzduohcc0+HvbFP8T7L8frqktmevXjXnqO5B/Vx4b70YZLR2dbPzC9VnnTf6lPB6jv1P3XnQr28fEvnY4IYZ1Ne6neEVVKDEZps79CVKa2Wkr3EQ+DrmXQAIOuZdAjsoqLEePdoA8vrLOPe7tHJd4+7mPZeDOpvcKQ3B1HfZn513TT/NOl/b28J69eT7f27t8pYfMtpBPxfqBCRwqP8/0aVYjiY9rnoZPRFZTU/TyP1g/M+wpzMiD5+xq1P2uNl7DoOAu8h+JNHHjruD9tHk635fF2LmxP+/hYvvs6K5X5bbW/5tPm4elwXbWdO7n+/gf621DRP95ftkdvf5Hx/DTRfi6S6GHB02SvGoXpNIrTaZRm08ir6TTS02lkptPITqcRTaeRm06j6dZsP92a7adbs/10a3aYbs0O063ZYbo1O0y3Zofp1uww3Zodpluzw3RrdphuzQ7TrdlxujU7Trdmx+nW7Djdmh2nW7PjdGt2nG7NjtOt2XG6NTtOt2anA9Zsb7bzFeQfml+/NMq859B+K9F6o6nydNoPWaWHBn2druckkhY0VyNorlbQXEnQXJ2guXpBcw2C5hoFzTXJmatWggKny2tySZMVFDppJSh20ookTVZQ9KSVoPBJK0Hxk1aCAiitJEVQWlIEpSVFUFpSBKUlRVBaUgSlJUVQWlIEpSVFUFpSBKUlRVBGUgRlJEVQRlIEZSRFUGaxCCruHTyPHY5fs82o7cKutnv4KuGOzWIBFys2i8VnrNgsFs6xYrNY9MeKzWLBIic2drHYkhWbxUJRVmwWi1xZsVks0GXFhoBNERvExWVsEBeXsUFcXMYGcXEZG8TFRWwIcXEZG8TFZWwQF5exQVxcxoaATREbxMVlbBAXl7FBXFzGBnFxGRvExUVsHOLiMjaIi8vYIC4uY4O4uIwNAZsiNoiLy9ggLi5jg7i4jA3i4jI2iIuL2HjExWVsEBeXsUFcXMYGcXEZGwI2RWwQF5exQVxcxgZxcRkbxMVlbBAXF7EJiIvL2CAuLmODuLiMDeLiMjYEbIrYIC4uY4O4uIwN4uIyNoiLy9ggLi5iExEXl7FBXFzGBnFxGRvExWVsCNgUsUFcXMYGcXEZG8TFZWwQF5exQVxcxGa1i4pYsUFcXMYGcXEZG8TFZWwI2BSxQVxcxgZxcRkbxMVlbBAXl7FBXFzCxqx2DxUrNoiLy9ggLi5jg7i4jA0BmyI2iIvL2CAuLmODuLiMDeLiMjaIi4vYrHa7GCs2iIvL2CAuLmODuLiMDQGbIjaIi8vYIC4uY4O4uIwN4uIyNoiLi9isdmfcW9h4TdvT3vpnbATHxZcFxX4/bQxlsBEcFxuKmyKGUnrGRnBcXMWGgE0RG8FxcRUbwXGx8WpT23gdnrERHBdXsREcF1exERwX17CRfN9dFRvJcXGwOzbBqWdsJMfFNWwkx8U1bAjYFLGRHBfXsJEcF9ewkRwX17CRHBfXsJEcF1ewkXzfXRUbxMVlbBAXl7FBXFzGhoBNERvExd/YhMrTwW8vs0K4v8uibxhFl5ZjvMP4XHaXfDVeFRvRpeUKNqJLy6+xkXw1XhUbySF0DRvJIXQNG8khdA0bAjZFbASH0JbcdvzNOv18xEvy1XhVbATHxVVsBMfFVWwEx8U1bCRfjVfFRnJcXDkaKPlqvCo2OIpcxoZwxOvPwhEvyVfjVbHBUeQyNjiKXMYGR5HL2ODIxXeN4vk1n+Sr8arY4MhFGRscuShjgyMXZWwI2BSxwZGLMjY4ilzGBkeRy9jgKHIZG8TFRWwkX41XxQZxcRkbxMVlbBAXf2Pz0ZFSybfo1Y5cSL5Fr4oNjiKXscFR5DI2OIpcxgZHkYvYSL5Fz6qkv5+22tIzNoJD6Co2gkPoKjaCQ+gqNgRsithIPopcw0byUeQaNpLjYndP2V2oPU16h4TMwyGEbxxxbPnKsdzxU8k37lWwsZJv3KtiIzmGrmEjOYauYSM5hq5hQzjS/Wf+SLeVfONeFRvJteUaNpJj6Bo2OLZ8xSZzbNlKvnGvho3kG/eq2Ij+zEUFG9Gfuahgg+MZV2wyR1es5Bv3qtjg2HIZGxxbLmODY8tlbHBsuYwNji0XsZF8414VGxxbLmODY8tlbBAXl7EhYFPEBnFxGRvExWVsEBd/Y/NJm4SVfTnfy6O5VvblfK+xkX05XwUbfEG5jA2+oFzGBl9QLmNDwKaIDdr5ytjg2PLX07ljy1by5XxVbCQfRa5hI/kocgUbyZfzVbFBO18ZG7TzlbFBO18ZGwI2RWwkx8V8bVlW9O18nDjixpKrr+ZaKiTf5FfFBq1/RWwk3+RXxQatf2Vs0PpXxgY3llz3+1wrjuib/GrYoPWvjA1a/8rY4MaSKza5dhPJN/lVsUHrXxEbyTf5VbFB618ZGxxxvmKTO3Io+ia/GjYEbIrY4IhzGRsccS5jgyPOZWzQ+lfGBq1/RWxwk98LbND6V8YGcXEZG8TFZWwI2BSxQVxcxgZx8Tc2H7W3ib70r3I0XvSlfzVs0PpXxEb0pX81bND6V8YGrX9lbND6V8aGgE0RG9xY8vV09vi35Jv8qtig9a+MDVr/ytig9a+IDW7ye4ENWv/K2KD1r4wNWv/K2BDasv5kaMuSfOsfK46S4+1KS4XkGwKr2KD1r4wNWv9K2BBu/XuBDVr/ythIrkO/bsUhybf+VbEhYFPEBq1/ZWwkH+V43W5Com/9q2GD1r8yNmj9K2KDW/9eYIMjzldsMkcOSfStfzVscMS5jA0BmyI2OOJcxgZHnMvYoPWvjA1a/8rYoPWviA1u/XuBDeLiMjaIi8vYIC4uY0PApogN4uJvbD5pbyPRFwS+PhpPoi8IrGGD1r8yNmj9K2KDW/9eYIPWvzI2aP0rY4PWvzI2hOPff+aPf5PkW/+q2KD1r4wNWv/K2KD1r4wNWv+K2ODWvxfYoPWvjA1a/8rYSI6L+dqySPINgaw4So63Ky0Vkm8IrGKD1r8yNmj9K2OD1r8iNrj17wU2kuvQlVYcybf+VbFB618ZGwI2RWwkH+WotJuIvvWvhg1a/8rYoPWvjA1a/4rYiL71r3LkUPStfzVscMS5jA2OOJexIWBTxAZHnMvYoPWvjA1a/8rYoPWvjA1a/4rY4Na/F9ggLi5jg7i4jA3i4jI2BGz+/Ly9TfQFgZWj8aIvCKxhg9a/MjZo/Stjg9a/Ija49e8FNmj9K2OD1r8yNrjd5Ovp7PFvybf+VbFB618ZG7T+lbFB618ZG7T+lbFB618RG9z69wIbtP6VsZEcFzO2ZUm+IZAVR0JLxZ+FlgrJNwRWsUHrXxkbtP6VsUHrXxkbtP6VsHGSb/2rtOI4ybf+VbFB618ZG7T+lbEhtJv8mW83caJv/athg9a/MjZo/Stjg9a/MjY44nzFJnPk0Im+9a+GDY44l7HBEecyNjjiXMaGgE0RG7T+lbFB618ZG7T+lbFB618ZG8TFRWxw698LbBAXl7FBXFzGBnHxNzaftLc50RcEvj4a70RfEFjDBq1/ZWzQ+lfGBq1/ZWzQ+lfEBrf+vcAGrX9lbHC7ydfTuePfTvKtf1VsCNgUsUHrXxkbtP6VsUHrXxkbtP6VsUHrXxEb3Pr3AhvJcTFfW5aTfEMgK46S4+1KS4XkGwKr2KD1r4wNWv/K2KD1r4wNWv/K2EiuQ1dacSTf+lfFBq1/ZWzQ+lfGRvJRjkq7iehb/2rYoPWvjA1a/8rYoPWvjA2OOF+xyR05FH3rXwUb3Pr3AhsccS5jgyPOZWxwxLmMDQGbIjZo/Stjg9a/MjZo/Stjg7i4jA3i4iI2uPXvBTaIi8vYIC7+xuaj9jbRFwRWjsaLviCwhg1a/8rYoPWvjA1a/8rYoPWvjA1a/4rY4Na/F9jgdpOvp7PHvyXf+lfFBq1/ZWwI2BSxQetfGRu0/pWxQetfGRu0/pWxQetfERvJt/5xtmVJviGQFUfJ8XalpULyDYFVbAjYFLFB618ZG7T+lbFB618ZG8l16EorjuRb/yrYeNz69wIbtP6VsZF8lON1u4kXfetfDRsCNkVs0PpXxgatf2VscMT5ik3myKEXfetfDRsccS5ig1v/XmCDI85lbHDEuYwNWv/K2BCwKWKD1r8yNmj9K2ODuLiMDeLiMjaIi4vY4Na/F9ggLv7G5pP2Ni/6gsDXR+O96AsCa9gQsClig9a/MjZo/Stjg9a/MjZo/Stjg9a/IjaSb/2rHP/2km/9q2KD1r8yNmj9K2NDwKaIDVr/ytig9a+MDVr/ytig9a+MjeS4mK8ty0u+IZAVR8nx9uuWCi/5hsAqNmj9K2NDwKaIDVr/ytig9a+MjeQ6dKUVR/Ktf1Vs0PpXxAa3/r3ARvJRjkq7iehb/2rYoPWvjA0BmyI2aP0rY4MjzldsckcORd/6V8MGR5zL2OCIcxEb3Pr3AhsccS5jg9a/MjZo/StjQ8CmiA1a/8rYIC4uY4O4uIwN4uIyNoiLi9jg1r8Nm4/a20RfEFg5Gi/6gsAaNmj9K2NDwKaIDVr/ytig9a+MDVr/ytig9a+MDW43+Xo6e/xb8q1/VWzQ+lfGBq1/ZWzQ+lfGhoBNERu0/pWxQetfGRu0/pWxkRwXM7ZlSb4hkBNHybcJ1loqJN8QWMUGrX9lbND6V8aGgE0RG7T+lbGRXIeutOJIvvWvig1a/8rYoPWvhE0Qfevf63aTIPrWvxo2aP0rY4PWvzI2BGyK2OCI8xWbzJHDIPrWvxo2OOJcxgZHnMvY4IhzERvc+vcCG7T+lbFB618ZG7T+lbEhYFPEBnFxGRvExWVsEBeXsUFcXMYGcfE3Np+0twXRFwS+PhofRF8QWMMGrX9lbND6V8aGgE0RG7T+lbFB618ZG7T+lbHB7SZfT+eOfwfJt/7VsMGtfy+wQetfGRu0/pWxQetfGRsCNkVs0PpXxgatf2VsJMfFfG1ZQfINgaw4So63X7dUBMk3BFaxQetfGRu0/pWxQetfGRsCNkVsJNehK604km/9q2KD1r8yNmj9K2Mj+ShHpd1E9K1/NWzQ+lfGBq1/ZWzQ+lfGhnCs7s/CkUPRt/7VsMER5zI2OOJcxgZHnMvY4IhzERvc+vcCG7T+lbFB618ZG7T+lbEhYFPEBnFxGRvExWVsEBeXsUFc/I3NR+1toi8IrByNF31BYA0btP6VsUHrXxkbtP6VsSFgU8QGrX9lbND6V8YGt5t8PZ09/i351r8qNmj9K2KDW/9eYIPWvzI2aP0rY4PWvzI2BGyK2KD1r4yN5LiYsS1L8g2BrDhKjrcrLRWSbwisYYNb/15gg9a/MjZo/Stjg9a/MjaEVpw/C604km/9q2KD1r8yNmj9K2Mj+ShHpd1E9K1/r7GJuPXvBTZo/Stjg9a/MjY44nzFJnPkMCoCNkVscMS5jA2OOJexwRHnMjY44lzGBq1/RWxw698LbND6V8YGrX9lbBAXl7EhYFPEBnFxGRvExWVsEBd/Y/NJe1sUfUHg66PxUfQFgRVscOvfC2zQ+lfGBq1/ZWzQ+lfGhoBNERu0/pWxwe0mX0/njn9Hybf+VbFB618ZG7T+FbHBrX8vsEHrXxkbtP6VsUHrXxkbAjZFbCTHxXxtWVHyDYGsOEqOt1+3VETJNwRWsUHrXxEb3Pr3Ahu0/pWxQetfGRvJdejXrThR8q1/VWzQ+lfGBq1/ZWwkH+WotJuIvvWvhg1a/4rY4Na/F9ig9a+MDY44X7HJHTkUfetfDRsCNkVscMS5jA2OOJexwRHnMjZo/Stjg9a/Ija49e8FNmj9K2ODuLiMDeLiMjYEbIrYIC4uY4O4+Bubj9rbRF8QWDkaL/qCwBo2aP0rYoNb/15gg9a/MjZo/Stjg9a/MjYEbIrY4HaTr6ezx78l3/pXxQatf2Vs0PpXxgatf0VscOvfC2zQ+lfGBq1/ZWzQ+lfGhtCW9SdDW5bkGwJZcZQcb1daKiTfEFjFBq1/ZWzQ+lfEBrf+vcAGrX9lbCTXoSutOJJv/atiQ8CmiA1a/8rYSD7KUWk3EX3rXw0btP6VsUHrXwmbhFv/XmCDI85XbDJHDpPoW/9q2OCIcxkbAjZFbHDEuYwNjjiXsUHrXxkbtP6VsUHrXxEb3Pr3AhvExWVsEBeXsUFcXMaGgE0RG8TF39h80t6WRF8Q+PpofBJ9QWANG7T+lbFB618RG9z69wIbtP6VsUHrXxkbtP6VsSEc//4zf/w7Sb71r4oNWv/K2KD1r4wNWv/K2KD1r4gNbv17gQ1a/8rYoPWvjI3kuJivLStJviGQFUfJ8fbrlook+YbAKjZo/Stjg9a/MjZo/Stig1v/XmAjuQ79uhUnSb71r4oNWv/K2BCwKWIj+ShHpd1E9K1/NWzQ+lfGBq1/ZWzQ+lfERvStf5Ujh6Jv/athgyPOZWxwxLmMDQGbIjY44lzGBq1/ZWzQ+lfGBq1/ZWzQ+lfEBrf+vcAGcXEZG8TFZWwQF5exIWDz5+ftbaIvCKwcjRd9QWANG7T+lbFB618ZG7T+FbHBrX8vsEHrXxkbtP6VscHtJl9PZ49/S771r4oNWv/K2KD1r4wNWv/K2KD1r4wNWv+K2Ii+9a9yFFn0rX81bCS3/tWwkRwX17AhYFPEBi16ZWymj4s9bZp4//Au4Ovp6wRmD14DqU2TQD4zgdkjzODVRrjgnak8rYPaCKdDSLWntfb7LJ2rcSGpLei6qP3wDik3yWhoUyQabx4fvsI+e/C6JuzT3863KOyzh9yLwj57NL8o7LMnCovCToD9CNhnT28WhX32zGlR2KfP99aEHVnqIbAjSz0Adq2mvyxzVdyRpx6DOxLVY3BHpnoM7gTcD8EdueoxuCNZPQZ3ZKvH4I509Rjcka8egvv0l9iuijvy1WNwR756DO7IV4/BnYD7IbgjXz0Gd+Srx+COfPUY3JGvHoM78tVDcJ/+xuhVcUe+egzuyFePwR356jG4E3A/BHfkq8fgjnz1GNyRrx6DO/LVY3BHvnoI7tPf5L4q7shXj8Ed+epPcQ9m/0BFMJ6eoUQKygYlAUouKJEo/hzKtH2dJ1idgRK5HxuUSOfYoESGxgYlki4uKAl5FBuUSI3YoES2wxVXErIdNigJUHJBiWyHDUpkO2xQItth28GR7bBBiWyHC0qHbIcNSmQ7bFAi22GDEtkOG5QEKH8KpU67Jtev/v8OJbIdNiiR7XBlOw7ZDhuUyHbYoES2wwWlR7bDBiWyHa640iPbYYMS2Q4blAQouaBEtsMGJbIdNiiR7bBBiWyHDUpkO1xQBmQ7XEW2gGyHK3EMyHbYoES2wwYlAUouKJHtsEGJbIctGEK2wwYlsh02KJHtcEEZke2wQYlshw1KZDtsUCLbYYOSACUXlMh2uIpsEdkOV+IYke2wQYlshw1KZDtcUCZkO2xQItvhCoYSsh02KJHtsEFJgJILSmQ7bFAi22GDEtkOG5TIdtigRLbDBKVWyHaYimxaIdthShy1QrbDBiWyHTYoCVByQYlshw1KZDtswRCyHTYoke2wQYlshwtKjWyHDUpkO2xQItthgxLZDhuUBCi5oES2w1Vk08h2uBJHjWyHDUpkO2xQItvhgtIg22GDEtkOVzBkkO2wQYlshw1KApRcUCLbYYMS2Q4blMh22KBEtsMGJbIdLigtsh2uIptFtsOVOFpkO2xQItthg5IAJReUyHbYoES2wxYMIdthgxLZDhuUyHa4oCRkO2xQItthgxLZDhuUyHbYoCRAyQUlsh2uIhsh2+FKHAnZDhuUyHbYoES2wwWlQ7bDBiWyHa5gyCHbYYMS2Q4blAQouaBEtsMGJbIdNiiR7bBBiWyHDUpkO1xQemQ7XEU2j2yHK3H0yHbYoES2wwYlAUouKJHtsEGJbIctGEK2wwYlsh02KJHtcEEZkO2wQYlshw1KZDtsUCLbYYOSACUXlMh2uIpsAdkOV+IYkO2wQYlshw1KZDtcUEZkO2xQItvhCoYish02KJHtsEFJgJILSmQ7bFAi22GDEtkOG5TIdtigRLbDBWVCtsNVZEvIdrgSx4Rshw1KZDtsUBKg5IIS2Q4blMh22IIhZDtsUCLbYYMS2Q4TlEYh22GDEtkOG5TIdtigRLbDBiUBSi4oke0wFdmMQrbDlDgahWyHDUpkO2xQItvhglIj22GDEtkOVzCkke2wQYlshw1KApRcUCLbYYMS2Q4blMh22KBEtsMGJbIdLigNsh2uIptBtsOVOBpkO2xQItthg5IAJReUyHbYoES2wxYMIdthgxLZDhuUyHa4oLTIdtigRLbDBiWyHTYoke2wQUmAkgtKZDtcRTaLbIcrcbTIdtigRLbDBiWyHS4oCdkOG5TIdriCIUK2wwYlsh02KAlQckGJbIcNSmQ7bFAi22GDEtkOG5TIdrigdMh2uIpsDtkOV+LokO2wQYlshw1KApRcUCLbYYMS2Q5bMIRshw1KZDtsUCLb4YLSI9thgxLZDhuUyHbYoES2wwYlAUouKJHtcBXZPLIdrsTRI9thgxLZDhuUyHa4oAzIdtigRLbDFQwFZDtsUCLbYYOSACUXlMh22KBEtsMGJbIdNiiR7bBBiWyHC8qIbIeryBaR7XAljhHZDhuUyHbYoCRAyQUlsh02KJHtsAVDyHbYoES2wwYlsh0uKBOyHTYoke2wQYlshw1KZDtsUBKg5IIS2Q5XkS0h2+FKHBOyHTYoke2wQYlshwlKq5DtsEGJbIcpGLIK2Q4blMh22KAkQMkFJbIdNiiR7bBBiWyHDUpkO2xQItvhglIj22EqslmNbIcrcdTIdtigRLbDBiUBSi4oke2wQYlshy0YQrbDBiWyHTYoke1wQWmQ7bBBiWyHDUpkO2xQItthg5IAJReUyHa4imwG2Q5X4miQ7bBBiWyHDUpkO1xQWmQ7bFAi2+EKhiyyHTYoke2wQUmAkgtKZDtsUCLbYYMS2Q4blMh22KBEtsMFJSHb4SqyEbIdrsSRkO2wQYlshw1KApRcUCLbYYMS2Q5bMIRshw1KZDv/zgUlsh0uKB2yHTYoke2wQYlshw1KZDtsUBKg5IIS2c6PoawU2RyynZ+z8nXi6JDtsEGJbIcNSmQ7XFB6ZDtsUCLb4QqGPLIdNiiR7bBBSYCSC0pkO2xQItthgxLZDhuUyHbYoES2wwVlQLbDVWQLyHa4EseAbIcNSmQ7bFASoOSCEtkOG5TIdtiCIWQ7bFAi22GDEtkOF5QR2Q4blMh22KBEtsMGJbIdNigJUHJBiWyHq8gWke1wJY4R2Q4blMh22KBEtsMFZUK2wwYlsh2uYCgh22GDEtkOG5QEKLmgRLbDBiWyHTYoke2wQYlshw1KZDtMUJJCtsNUZCOFbIcpcSSFbIcNSmQ7bFASoOSCEtkOG5TIdtiCIWQ7bFAi22GDEtkOF5Qa2Q4blMh22KBEtsMGJbIdNigJUHJBiWyHq8imke1wJY4a2Q4blMh22KBEtsMFpUG2wwYlsh2uYMgg22GDEtkOG5QEKLmgRLbDBiWyHTYoke2wQYlshw1KZDtcUFpkO1xFNotshytxtMh22KBEtsMGJQFKLiiR7bBBiWyHLRhCtsMGJbIdNiiR7XBBSch22KBEtsMGJbIdNiiR7bBBSYCSC0pkO1xFNkK2w5U4ErIdNiiR7bBBiWyHC0qHbIcNSmQ7XMGQQ7bDBiWyHTYoCVByQYlshw1KZDtsUCLbYYMS2Q4blMh2uKD0yHa4imwe2Q5X4uiR7bBBiWyHDUoClFxQItthgxLZDlswhGyHLRhCtsPm4Mh2uKAMyHbYoES2wwYlsh02KJHtcAVDgQAlUzAUkO2wOTiyHTYoke2wQYlshw1KZDtcUEZkO1zBUES2wwYlsh02KJHtsEFJgPKnUJLZNSETnqFEtsMG5WLZTtRq1yRQ5WkyG5Jk779slMo8m2zcjJRI/QLk88PW7fBZrx7S9ZB72NhNDWvIPD58M9FiWdSKJlosO1vRRItlfQuaKC2WTZ7RRNaH7WEb47OJFstSVzTRYtnviiZaLKs+o4kuP7c9TMa8fthEu03QRKo9rGl/WLvwbHyC8dc1vlFbEcgYW3nYBfv9rEvpKTNPixU5wJNOPEEFBzz5CU9QRlqZJ87tPAnxI56glgWe/IQnKKgtzJN7Bmtssr8nMU6hVCfY+CgCCjY+yosLG592NYyz4fXD2sXdiP4Lgt+ZgionmPIzphCYAqZcoQtmN3lw+oP8xCnUT0EqdlKh2ApSsZMKlVmQ6ptUYYcu/Jp8vU0qlHFBKnZSoeZ7MlJ5v5OqVu6vHFxxGjXfhY3P9qLZaZSHwZOf8ASV5JV5wvWi2WnUkcGTn/CEwJN1eVJ5LalR7RVsfFRlBRsf1dOFjc/5mlmjJAqm/IwpqHOCKTfo+F7zGdRPQSp2UqHYClKxkwqVWZDqm1Rs744NyrggFTupCKQ6FakSbWqYFD7M0gxqvoKNj5rvwsZnjGVRHgZPfsITFIfBk5/wBKXhlXnClplYVHvBk5/wBAXc43kS7c6TVKt0MH4L0lkUWhc2Pt9RaYvaKXjyE54QeAKe/IAnqJyuzBO2I/UWRVbw5Cc8QZF1YZ5UDmBbVE4FGx/lULnGJ9Q4FzY+54F6QpUTTPkZU1ASBVNu0PG9tCXUT0EqdlIRSAVScZMKlVmQ6ptUbGcMCGVckIqdVKj5noxUjN+CJNR8FzY+34tmQnkYPPkBTxwqySvzhO1Fs0MdGTz5CU9QRV6YJ5XXkg7VXsHGJxhfrvFRPV3Y+JyvmR1KomDKz5iCOieYcoOO7zWfQ/0UpGInFYqtIBU3qTwqsyDVN6nY3h17lHFBKnZSoeZ7LlJxfg7Qo+Yr2PgE469rfMZYFuVh8OQnPEFxGDz5CU9QGl6ZJ3yZCaq94MlPeCKngHudb5i+thjDdsI1JLKVp53ajUsPSYpT2YpK2E8yJH2ngs/9cIykvx+OKfjKw0ZvNormwUYmptwME+0WTQ/szT9t3e7L5j5DkzOLMWkzi7HKvX5Y27sNrdWVh5XejKKVj48P31g1fXERrDohq6avLoJVzawKu+1NsLZClBD8fb93H7Jq+rIlWHVCVpFYVl02he2XrXqI87NEuSCyN9peENHgVYVX09dP3+OVpz0ZixVe0eVV5m6g+JjLfL+DCNPXDA/EZvo62YHYTF8begubuBcIYrC1CMCavd+LSFdWSKy+01eHwJQ5mBLXqqsls8X+ybkKU5wK++KslX1eb+Na1SFebNaqccS95K/V4/uB/BKj/b35+GGOWGLyS8xahQtQpSNVCFTJUeUGzvQpdXLhTsjqKz91UX2HR9s7daLJxnVqr+td/g7q8fEbPtOn1QfjM31qfTA+06fXB+MzfVJ5LD5prVSKd/NKHLmUubxa3aT4X74ilgPn6zDV9tvePRyhsbn4yCR1P8jjalUGUvuLBlKUnvOjZITN1wqbL00+X6vUtlxZFav+i6rZO3lKcrC+YOv72a2v1X7c9ZdP8ubXupB20OPjW/N9rQvC5hunn2/Y52tMbb6oQb3n3UmM9b/m65UaP18f9W4vHWvzpd1glqhy8EZbu+WA2saHjMjo7+lqWdM1sqZrZU2XZE3XLTVd2qPuS+jhf5ludtVXe4zzENFfNsps/G91LiK6/GPiPf+oE/teeRALxOpBrABigVg9iBVBLBCrB7ESiAVidSCWXqvOAGJNQ6y1Kjog1jTEWqt2BmJNQ6y1qpQg1jTEIhALxOpBLFTeQawuxELlHcTqQixU3kGsLsRC5R3E6kIsVN5BrB7EMqi8L02so47KeoPKO4jVhViSK+9Gb6cgrX24QCtPLFBFci0dVHmLKiSYKmR2qlDQFaoYot1GFB9aTHzuYU3bTmh+6b4K37BLrh13hN2o/WHzCyKZh19eJuGN5CLsOSwkuZrZ00Lu3hxXu6y0YiHJZcFzWEhyfa2jhazfP85vf73U6Aq7lVx9OhB2ybWZA2GXXLnoCPtbF4W/vgPYW8klg7PYiGCjw23Edv2pt6gBLGVOFAyWMieqCxOYk+tuWG9RiljKnKLrFur+08FUzEm0n5qhy/+9NqcNeyZno7aPD19hJ9F1i36wx7SfhEg52EXXLY6DXXTd4jjYRZcijoOdAPsRsIuuAhwHu+hs/TjYRWfVx8EuOvs9DnZkqd+w186Ca7Wfl9PqoUSRhd3ptF/EaDQ9we6QpR4CO7LUQ2BHlnoI7MhSu8BuyO+we/8MOwH2I2BHlnoI7MhSD4EdWWoX2H3Y5uiCruRWwdvNRsHH59zKIaWd30bIf6e3kUeyPL+NkFl3sVHUu43iQ/Nvm42Qhs9vI+TsfcLp/fJIZ214hp0A+/GukfZ74IPWzzZCgj+/jVANmN9Ga5UOarcP+rWy8Op010poa9MNyA2/FxzmYwO0nW230T3HSwHp3iGwI4M7BPbFkjIVS7Dfpkuypjt/XhE3P7FO6cp09e4mWps78fOfrPzFS+7PqtyzC35aLkyfrlxe/u2mp1QxvaK0L6jKPZR0o8k+ntT98US/PH6DZ/pM4Vh4ps8sjoVn+kykJzw6ul2Vy5TTEzxx+szlWHimzzC6wpPuobFOZF4/LnwXj9NnReOo4tyzJ02fvRwLD0mGxyi9nSG+/O3NMzzTZ0fHwjN/BhH27yUEFV7DI/5b43H+jAfmfMOc82doMOcb5pw/o4Q5f27OND4DNrSfAzLu8emsOb3fLeQffzsbKxiraKPK5e+gnmKFpIXN10w/X9qiu8sbTV+JBZ3ZP33q4sP3vvz3B7+SnX26YY+UL+94KtO9BP47NvHhfMr3K7FEkibrJE3WS5pskDTZuNRk7+8fLjtNeJpskjPZoKaPpDgnO30YxTnZ6WMozsmuFUFVJkuSJrtWBFWZ7FoRVGWya0VQlckKiqCCkhRBaUkRlJYUQWlJEZSWFEFpkjTZxSKoe+U1uefJLhZBvZ7sYhHU68kuFkG9nuxiEdTLyZrFIqjXk10sgno92cUiqNeTXSyCej1ZkjRZSRGUkRRBGUkRlJEUQRlJEZSVFEFZSRGUlRRBWUkR1AEXXh84WUkRlJUUQVlJEZSVFEFZSREUSYqgSFIERZIiKJIUQR1wqeeBk5UUQZGkCIokRVAkKYIiSRGUkxRBOUkRlJMUQTlJEdQBF84dOFlJEZSTFEE5SRGUkxRBOUkRlJcUQXlJEZSXFEF5SRHUAdf/HDhZSRGUlxRBeUkRlJcUQXlJEVSQFEEFSRFUkBRBBUkR1AF3hhw4WUkRVJAUQQVJEVSQFEEFSRFUlBRBRUkRVJQUQUVJEdQB9xAcOFlJEVSUFEFFSRFUlBRBRUkR1PzfJuecrKQIav6vknNOVlIEtdg3ySuTlRRBLfZN8spkJUVQq32T/PVkBUVQcbVvkr+erKAIKha+SW5UtNtkjXq40tXR97h8MGL0flmRNsb61yBp7dT+uHbm/njIXXdqYtxuZDLJ3++o0Sr74y7tNyhc/n68syh7zZLRO6pG0/06JKt87tet3wEirX55+gYQ8QBkHwDy6TVA1m9fnST9QKKL1W8qOR6Vwv1Sem/Ma5V08mkHKgWtXrO1ehFRLHyQ+2STCCtMIo6fhFHWbk5tlLPpF60u//jX//jr3/721//1z3/7x7/9y3/99R9//8+vwerr/+U7Kx7WFKvc48p7XejyHQq1Qb5lUGgZFFsGpYZB+ZPQtUG6ZZBpGWRbBrUwwrcwwrcwwrcwwrcwwrcwIrQwIrQwIrQwIrQwIrQwIrQwIrQwIrQwIrQwIrQwIrYwIrYwIrYwIrYwIrYwIrYwIrYwIrYwIrYwIrYwIrUwIrUwIrUwIrUwIrUwIrUwIrUwIrUwIrUwIrUwQivVNEo3jTJNo2zTKGoa5ZpG+aZRoWlUbBrVxI38xS3W01Z4sT4+lDtCLp8IcU8PHi9WzlVdLjn697PxIZHIP5viltSk9OuzV8X1WRU3Z1XcnlVxOqvi7qyK+7MqHs6qeDyr4umkipuz7pzmrDunmXjn9Pt7D6XMs+YTb50VzSfeOyuaT7x5VjSfePesaD7x9lnRvLB/7u9vbNTxteaXt5m76pruL2+Syr03TNu7atL3m+a1v703zN/bYKPZXjba5ENFG7urbpx6eGmTrhLylyWwStDdJZjuEmx3CdRdgusuwXeXELpLiN0ldPdp6u7T1N2nqbtPU3efpu4+Td19mrr7NHX3aeru09Tdp113n3bdfdp192nX3addd5923X3adfdp192nXXefdt192nf3ad/dp313n/bdfdp392nf3ad9d5/23X3ad/dp392nQ3efDt19OnT36dDdp0N3nw7dfTp09+nQ3adDd58O3X06dvfp2N2nI4NP34+LG//V9/GbBNtdAnWX4LpL8N0lhO4SYncJqbeEpHglaPckgcGnnd77oryxjxJ6vl9N5rSa29NqTqfV3J1Wc39azcNpNY+n1TydVHOj1Gk1P+seatRZ91CjzrqHGnXWPdSomffQlwdmjJp5E62oPvMuWlF95m20ovrM++hr1fXMG2lFdYad1NP+DRBP8bd812jTXYLtLoFhB/H7p0+CfarDGe26S/DdJYTuEmJ3Cam3BKO6S9DdJZjuEmx3Cd192nT3adPdp013nzbdfdp092nb3afzp0O1c5sE7dV92wqUjRq2CCPS/ff17fNhJn84lFOA7i3A9BZgewug3gLc5wL2Z2PwvwjIcFrtXQyXGPn+NOU+3xb3z9ulX76URvmXmnu0TOrhw3DkbvP0QuYZhMwzCplnfZU3v8zza5BTLYN0y6Ds8hGc2/qawuP3ELOpa9i/0RjCL8Bef99//PvGhz2RCw/57vc2mj+AyiohdpeQekvIH0BllaC7SzDdJdjuEohDgrlLoCcJBX+Iapfw2JCZ3g9cfewuIfWWEFR3Cbq7BNNdgu0ugbpLcN0l+O4Suvt06O7TobtPx+4+Hbv7dOzu05HBp8P9E+FRm8rDNu498pdY+fcANNJc6ri51PFzqRPmUifOpU6aSp2k5lJHD1dH3dV5SnyTmUsdO5c6o1dlp+4tDQ8HrLN1H1J++2Y+qZCedHdT6x73r8CojJP4s+Ce0X305kD7RRzGPZyvaCiip3he1dNZVbdKnVd1fV7VzWlV1zSz6u+8jdB210K7+8fAsm8jLnp+P3uh3eOjV0gcIPkdEg9Ifodk6q35GEim3vKPgWTqUOIQSMzUIcoxkEwd+hwDydQh1TGQWEDyOyQESH6HBNHrEySIXp8gQfT6BAmi1ydIEL3+DolF9PoECaLXJ0gQvT5Bguj1CRICJL9Dguj1CRJEr0+QIHp9ggTR6xMkiF5/h4QQvT5Bguj1d0jcMizp1aGm02VS309f/jb3562yNwyXodWBGC6TRR2I4TJp14EYEjD8GMNlErsDMVwmEzwQw2VSxwMxXCbXPBDDZZLT4zD0yFM+xxB5yucYIk/5HEPkKZ9jSMDwYwyRp3yOIfKUzzFEnvI5hshTPscQecrHGAbkKZ9jiDzlcwyRp3yOIfKUzzEkYPgxhshTPscQecrnGCJP+RxD5CmfY4g85WMMI/KUzzFEnvI5hshTPscQecrnGBIw/BhD5CmfY4g85XMMkad8jiHylM8xRJ7yMYYJecrnGCJP+RxD5CmfY4g85XMMCRh+jCHylM8xRJ7yOYbIUz7HEHnK5xgiT/kUQ5r7Y/wnwRB5yucYIk/5HEPkKZ9jSMDwYwyRp3yOIfKUzzFEnvI5hshTPscQecrHGGrkKZ9jiDzlcwzXyVNCumMYXmP46lN8pNdJO9ggIUDyGySH3gxj1WtIgt/WiBD8k+Z0Ws3daTVnSH8i7ZqnB+pmH7YmbTdQWvuw7GsfbvqEyfSJk+mT5tKH4woMVn30ZPqYyfSxk+lDk+njJtNnsvXZdl2frxJidwmptwSOT6snvyVIVlMlHoiKtkjTpv1RE2Pm2RQ3A6f067NXzfVpNTen1dyeVnM6rebutJr702oeTqt5PK3m6ayau9Puoe60e6g77R7qTruHcnxAOxnao1HSv0ejHJ+Xfi2B4+PLFQm6uwTTXYLtLoG6S3DdJfjuEkJ3Cd192nf36dDdp0N3nw7dfTp09+nQ3adDd58O3X06dPfp0N2nQ3efjt19Onb36djdp2N3n47dfTp29+nY3adjd5+O3X06dvfp1N2nOdrDKxK6+3Tq7tOpu0+n7j6duvt06u7TqbtPp94+7ZTqLkF3l2C6S7DdJVB3Ca67BN9dQuguIXaX0N2ndXef1t19Wnf3ad3dp3V3n9bdfVp392nd3ad1d5/W3X3adPdp092nTXefNt192nT3adPdp013nzbdfdp092nT3adtd5+23X3advdp292nbXeftt192nb3advdp213n7bdfZq6+zR192nq7tPU3aepu09Td5+m7j5N3X2auvs0dfdp192nXXefdt192nX3adfdp113n3bdfdp19+nu58hc93Nkrvs5Mtf9HJnrfo7MdT9H5rqfI3Pdz5G57ufIXPdzZK77OTLnZz4f7rdntVLml4e/VA8zHxCvqD7zCfGK6jMfEa+oPvMZ8YrqdF7Vu3ZaXSV8vtJb7dUu4esrCr9JCN0lxO4SUm8JDKcLaxJMdwm2uwTqLsF1l9Dd42J3j4vdPS5297jU3eMYzv7VJHT36dTdp1N3n07dfTp19+nU3adTd59OvX3aK9Vdgu4uwXSXYLtLoO4SXHcJvruE0F1C7C6hu0/r7j6tu/u07u7TurtP6+4+rbv7tO7u07q7T+vuPq27+7Tp7tOmu0+b7j5tuvu06e7TprtPm+4+bbr7tOnu06a7T9vuPm27+7Tt7tO2u0/b7j5tu/u07e7TtrtP2+4+bbv7NHX3aeru09Tdp6m7T1N3n6buPk3dfZq6+zR192nq7tOuu0+77j7tuvu06+7TrrtPu+4+7br7tOvu0667T7vuPu27+7Tv7tO+u0/77j7tu/u07+7TvrtP++4+7bv7tO/u06G7T4fuPh26+3To7tOhu0+H7j7d/ZSX737Ky3c/5eW7n/Ly3U95+djdp7ufI/Pdz5H57ufIfPdzZJ7jHJlT28Vp9qLx64fZvtrsOc6nHaR5PK3maWLNXx6C9hwH9Y5SXZ9XdXNe1e15Vafzqs6w4wW9Xbdog0mvH351NaPnOJDJp0yYSZnYU5mrhNRZQuA45lmR8PnCTcptN82SCqqijklxU8fqe6znb9qYqbSxU2lDg7Wxfl9ebQwP2mR+WO+ak9Hhd83daTX3rJprY578L3SXELtL+HwdJG92M1xWvdcPawr7Bu30/X5tnXJPe7X9sjf+4dnrZh4YDt0ep7s+se7mxLrbE+tOJ9bdnVh3f2Ldw4l1jyfW/cT7qjnxvmpOvK+aE++r5sT7KkODwXG6n3hfNXOv77Q97J1+0t3Ovc7sn1PxPj7rPnqdcdrtulv6RferPnYyfWgyfdxk+gyPh0nf9XEV7msffNge9yGq3+pCNpxa+3hq7dOZtSd1au277lhXCaa7BNtdAsPaH9z21oaSspWH02Yzpx9XWpd51lzesXw/bMJDKffbvu60mvvTah5Oq3k8rebprJozNDUdpbk+rebmtJrb02p+2j3UnXYPdafdQ91p91A3zR561WaaffFLGz/NXnfVZpr966rNNHvSVZtp9pmrNtPsHVdtptkPrtpMs8ZftRm8bjuzFUMcxcq6rVW02y9f/na/10J8PLHu6by6B3Vi3e3Muqf9lN/lb69/191PrfuuhtZK+d91n3qdqeg+9TpT0X30OuP23SZSVfeQ3N1X9e+6R3Vi3fWJdTcn1t3OrPvrvYmhVfg43d2Jdfcn1n3q9f11PJOmXmde76tp6nWmovvU60xF967rzFWC7y4hdJcQu0tInSVEhs5LSrTFCs5S7ZzG5S3TRrxLen5/ONeg/LKkHDlaOo9S3ZxXdXte1em8qrvzqu7Pq3o4r+rxvKqn06quz7ub6vPupvq8u6k+727K0WF7lOrn3U31eXdTfd7dVJ93N9Xn3U3NPLvpVZ15dsirOvPseld15tnJrurMsztd1Zlnx7mqM88uclVnnp3hqs48q/1VnXlW8C917Fyrsp1rVbZzrcp2rlXZzrUq27lWZTvXqmznWpXtXKuynWtVprlWZZprVaa5VmWaa1WmuVZlmmtVprlWZZprVaa5VmWaa1V2c63Kbq5V2c21Kru5VmU316rs5lqV3VyrsptrVXZzrcpurlXZz7Uq+7lWZT/XquznWpX9XKuyn2tV9nOtyn6uVdnPtSr7uVblMNeqHOZalcNcq3KYa1UOc63KYa5VOcy1Koe5VuUw16oc5lqV41yrcpxrVY5zrcpxrlU5zrUqx7lW5TjXqhznWpXjXKtynGtVTnOtymmuVTnNtSqnuVblNNeqnOZaldNcq3Kaa1VOc63KaapVOU3US3tVZ6pVOU3U83pVZ6pVOampVuU0Ub/pVZ2pVuU0UV/oVZ2pVuU0Uf/mlzoT9WRe1ZlrVZ6od/Kqzlyr8kQ9jld15lqVJ+pFvKoz16o8Uc/gVZ25VuW5evvSXL19aa7evjRXb1+aq7cvzdXbl+bq7Utz9faluXr70ly9fWmu3r40V29fmqu3L83V25fm6u1Lc/X2pbl6+9JcvX1prt6+NFdvX5qrty/N1duX5urtS3P19qW5evvSXL19aa7evjRXb1+aq7cvzdXbl+bq7Utz9faluXr70ly9fWmu3r40V29fmqu3L83V25fm6u1Lc/X2pbl6+9JcvX1prt6+NFdvX5qrty/N1duX5urtS3P19qW5evvSXL19aa7evjRXb1+aq7cvzdXbl+bq7Utz9faluXr70ly9fWmu3r40V29fmqu3L83V25fm6u1Lc/X2pbl6+9JcvX1prt6+NFdvX5qrty/N1duX5urtS3P19qW5evvSXL19aa7evjRXb1+aq7cvzdXbl+bq7Utz9fZpNVdz30Wfqdbliz5TLcwXfaZamS/6TLU0X/SZam3+uoN4Mn2mWp0v+oxenpPaflknm9Fn+Poc/K5PUo/6PD8cFX0/Gx9UN9lnL8na97OXPeeXZ6/zHN8+eNA8tZB5GiHztELmSULm6YTM0wuZZxAyzyhknkLiISMkHjJC4iEjJB4yQuKh8c3RB81TSDxkhMRDZpl4yG/PfhVFMxNdJiCqTXSZiKgyUbtMSFSb6DIxUW2iywRFtYnOExXd9KHJ9JknyrjpM080cNNnnl37ps88m+tNn3n2wKs+NM9WddNnnh3lps88C/9Nn8nWZ5psfR79PQGjQ/p+mEJyrzdqsnF71tP+qE4h98P3161W60oE4NX+y14Fe/9pa79h8SJhcbRFO94FlYElAJYcLBGw5GBJgCUDy+jvXpwFFg1YcrAYwJKDxQKWHCwEWHKwyIxyq7Agys3Cgig3Cwui3CwsiHJzsHhEuVlYEOVmYUGUm4UFUW4WFgIsOVgQ5WZhQZSbhQVRbhYWRLlZWBDl5mAJiHKzsCDKzcKCKDcLC6LcLCwEWHKwIMrNwoIoNwsLotwsLIhys7Agys3BEhHlZmFBlJuFBVFuFhZEuVlYCLDkYEGUm4UFUW4WFkS5WVgQ5WZhQZSbgyUhys3Cgig3Cwui3CwsiHKzsBBgycGCKDcLC6LcLCyIcrOwIMrNwoIoNwOLVohys7Agys3Cgig3Cwui3CwsBFhysCDKzcKCKDcLC6LcLCyIcrOwIMrNwaIR5WZhQZSbhQVRbhYWRLlZWAiw5GBBlJuFBVFuFhZEuVlYEOVmYUGUm4PFIMrNwoIoNwsLotwsLIhys7AQYMnBgig3Cwui3CwsiHKzsCDKzcKCKDcHi0WUm4UFUW4WFkS5WVgQ5WZhIcCSgwVRbhYWRLlZWBDlZmFBlJuFBVFuDhZClJuFBVFuFhZEuVlYEOVmYSHAkoMFUW4WFkS5WVgQ5WZhQZSbhQVRbg4W3H2WhwVRbhYWRLlZWBDlZmEhwJKDBVFuFhZEuVlYEOVmYUGUm4UFUW4OFtx9locFUW4WFkS5WVgQ5WZhIcCSgwVRbhYWRLlZWBDlZmFBlJuFBVFuDhbcfZaHBVFuFhZEuVlYEOVmYSHAkoMFUW4WFkS5WVgQ5WZhQZSbhQVRbg4W3H2WhwVRbhYWRLlZWBDlZmEhwJKDBVFuFhZEuVlYEOVmYUGUm4UFUW4OFtx9locFUW4WFkS5WVgQ5WZhIcCSgwVRbhYWRLlZWBDlZmFBlJuFBVFuBhaDu8/ysCDKzcKCKDcLC6LcLCwEWHKwIMrNwoIoNwsLotwsLIhys7Agys3BgrvP8rAgys3Cgig3Cwui3CwsBFhysCDKzcKCKDcLC6LcLCyIcrOwIMrNwYK7z/KwIMrNwoIoNwsLotwsLARYcrAgys3Cgig3Cwui3CwsiHKzsCDKzcGCu8/ysCDKzcKCKDcLC6LcLCwEWHKwIMrNwoIoNwsLotwsLIhys7Agys3BgrvP8rAgys3Cgig3Cwui3CwsBFhysCDKzcKCKDcLC6LcLCyIcrOwIMrNwSL07rMQ7AZLNPEXWHJP6/1h/6BG/IZQZkTMCqHM6JkVQpmRNiuEBAg/hVBmBM8Kocho36W0qRyisxUIbaQNQxv9HXCfe1iT2X5aU3hA3OjcT+tw1/oBaBOyTyu7K6Jd2J++/CPzdNR+0yQale6/nbdiUHY3jDb33/b6mykiEyAwpYEpInNCMKWBKSLTZDDlfabIvE8STGlgisgCCZjSwBSRdSAwpYEpIstdYEoDUwhMAVN+xBSRxUswpYEpqNGCKT9jCmq0YMrPmIIaLZjyM6agRgum/IgpMm9DB1MamIIa7aFMIbXBYSmYClPIarMBYr+e2H7bfxsTZdSFjIlK50LGJBhzHWOiXriQMVHSW8iYqLotZEwUxhYyJmpX6xgzory0kDFRAVrImKgALWRMARWg20RJykQFVA5uExWQVd8mKiDjvE1UQDZ2m6iATOU60SQgir9NVECEe5uogOjvNlEpkVEiKROVEhklKZFRkhIZJSmRURISGVklJDKySkhkZJWQyMgqIZGRVSRlokIiI6uEREZWCYmMrBISGVklJTLSUiIjLSUy0lIiIy0lMtIkZaJSIiMtJTLSUiIjLSUy0lIiIyMlMjJSIiMjJTIyUiIjQ1ImKiUyknDd/W2iUiIjCVfS3yYqJTKScG38baJSIiMJV7vfJiolMpJw/fptolIiIwlXpN8mKiUyknCN+W2iUiIjCVeN3yYqJTKScB34baJSIiMJV3bfJiolMpJwrfZtolIiIwlXX98mKiUyknA99W2iUiIjCVc93yYqJTKScG3ybaJSIiMJVxDfJiolMpJwAextolIiIwnXb94mKiUyknD54W2iUiIjCVfP3SYqJTKScPHXbaJSIiMJ1y7dJiolMpJw6c1tolIiIwn3mdwmKiUyknAPxm2iUiIjCfcn3CYqJTKS8N3920SlREYSvtd+m6iUyEjCd75vE5USGUn5BraV8g1sK+Ub2FbKN7CtlG9gWynfwLZSvoFtpXwD20r5BraV8g1sK+Ub2FbKN7CtlG9gWynfwLZSvoFtpXwDm6R8A5ukfAObpHwDm6R8A5vm/qSl3idqwi8Tvek+Twxw02eerfqmzzw76k2feTa+qz4TfW/vps8828hNn3lW+5s+86xVN31oMn3mSf5u+ky2Pk/0AbSbPpOtzxN9Tuyqz0Rf/brpM9n6PNE3tG76TLY+T/RFqps+k63PE33f6abPZOvzRF9Luukz2fo80beHbvpMtj5P9CWfmz6Trc8TfRfnps9k6/NEX5m56TPZ+jzRN1tu+ky2Pk/0BZSbPpOtzxN9T+Smz2Tr80Rf57jpM9n6PNG3Lm76TLY+T/TliJs+k63PE32H4abPZOvzRF81uOkz2fo80TcCbvpMtj5P1HF/02ey9Xmi/vWbPpOtzxN1g9/0mWx9nqi3+qbPZOvzRJ3KN30mW58n6vu96TPZ+jxRF+1Nn8nW54l6Um/6TLY+T9ThedNnsvV5on7Jmz6Trc+juw8pBrPpk5R91ieM1kfd9dH6UZ/nh6Oi72ejTfujJvtsiv772ZR+ffY2zyhknknGPEd3CB42Ty1knkbIPK2QeZKQeToh8/RC5ikkHkpC4qEkIx5ySkY85NQy8ZDfntVKmcxElwmIahNdJiKqTZSkTHSZmKg20WWCotpEu0ZFNxGxv4jUXYRW/UXo/iJMfxG2vwjqL8L1F+H7i+jv3bq/d+v+3m36e7fp792mv3eb/t5t+nu36e/dpr93m/7ebfp7t+nv3ba/d9v+3m37e7ft7922v3fb/t5t+3u37e/dtr932/7eTf29m/p7N/X3burv3dTfu6m/d1N/76b+3k39vZv6e7fr792uv3e7/t7t+nu36+/drr93u/7e7fp7t+vv3a6/d/v+3u37e7fv792+v3f7/t7t+3u37+/dvr93+/7e7ft7d+jv3aG/d4f+3h36e3fo792hv3eH/t4d+nt36O/dob93x/7eHft7d+zv3bG/d8f+3h37e3fs792xv3fH/t4d+3t36u/dqb93p/7enfp7d+rv3am/d6f+3p36e3fq792pu3d7pfqL0P1FmP4ibH8R1F+E6y/C9xcR+ouI/UX09+7+Z9V8/7Nqvv9ZNd//rJrvf1bNM5xVu7wz35qbL/Xx9PphvkP/nuEM3GGqh/OqHs+rejqt6gxnDA9TXZ9XdXNe1e15Vafzqn7e3dScdzc1591NzXl3U3Pe3dSedze1M++mr/vFvJ15O63pPvN+WtN95g21pvvMO2pN95m31JruXffUm4jYX0TqLoJUfxG6vwjTX4TtL4L6i3D9Rfj+Ivp7N/X3burv3Qxnr93lpf73w/4Svr1++PU9zJ7hhPMLdW4ifH8Rob+I2F/E5+wLyurtYeUqu7sJOnw/bIK5f0M00E0fhuPQvProyfQxk+ljJ9OHJtPHTaaPn0yfMFofol0f75/1iZPpk+bSJwxen+3lhdf3w1aH9KyPnkwfM5k+djJ9aLQ+zrzUZ/D6Y623mz42mGd94mT6pLn0iWoyfUavP9apXR//iz6ZPEztzkgqQ/5oplY+7h+EU+l5J4r2LMjnlB+9DNq0L8v0cFVCG23c1MpXaOPPgnxO+dG7FZm4K+/Usz5xMn3SXPokNZk++kh96FkfM5k+djJ9aDJ9Rq/8Zr9xyJJPrxfPr+Dw+2Ed6L5Ba7dpP3r1DHaPHQO5zzbdFKdW/vWmm9JZkH9WPqjRi/hlGdqV/7UEkyG92h/W2qon0gc1eskPYTv6Y+OvW1AO+q04SOZXh83M1KZtbdL08IHoy0L1PVMjZqZWzExJzEydmJl6MTMNYmYaTznTm+7pvLprdWLdp45M7KYFhZjRfepYo6J7YU9Nm4TgdXxU5zbKNY3yTaNC06jYNCq1jCp1slVG6aZRpmmUbRrVxA3TxA3TxA3TxA3TxA2ONgW+c3PBTnWML3A0E3CqQ3Op4+ZSx8+lThisDu1bovtVnZzq6a67vj/tv1WP51U9nVZ1jgaFo1TX51XdnFd1e17V6byqu/Oq7s+r+nl3Uzrvbkrn3U3deXdTd97d1J13N3Xn3U0Zruw4TPXz7qbuvLupO+9u6s67m7rz7qb+vLupH72b2l0bTxXVa+e5gjdnVt6eWXk6s/LuzMr7Mysf5lXepX2h9E7F1z+so9ne3Rql7ucLtf+ub/soZqbplDO96h7UiXWfZue+qfP5jvDiI8/PD19ime1kOIV052X2M1GVl1F9b23qrLs/se7hxLrHE+uezqt73yu3OuuuZ9adL6nse6HYRPO0QuZJQuY5dRzAOM+pYwbGeU4dXzDOc+pY5I2cp/I51xCnDlwYJ5qmjnI4Jzp1SMQ50aljIs6JTh0UcU6UpEx06rCIc6JTx0WcE506MOKcqJTIKAmJjKISEhlFJSQyikpIZBSVkMgoKpIyUSGRUVRCIqOohERGUQmJjKKSEhlpKZGRlhIZaSmRkZYSGfW9Cn2miUqJjLSUyEhLiYy0lMhIS4mMjJTIyKwSGRlH2w8bl+LrH9bJbV/xubwn1w+wpG9YVomj3oMl7l+GNcr+Csvz05eNbJvgxV9S5WmK90+7XR7fn7Zef0O+SkR3IsgJkI+GfJUo90SQrxJvnwjyVSL/E0G+Sg5yIshXyYbOA7ldJS87EeQyM8RDIUf2ORxyZJ8fQX4DkQDi5yAiQ2QAETlfHUSj7yA6U3k63OEIKdnK03avr9LDamsoC13arw832jw+fDMlcsllTIkcdRlTIvddxZSEnHoZUyJXX8aUqAEsY0rUFpYxJcGUq5gSdZZlTIlqzzKmRLVnGVOi2rOMKVHtWcWUDtWeZUyJas8ypkS1ZxlTotqzjCkJplzFlKj2LGNKVHuWMSWqPcuYEtWeZUyJas8qpvSo9ixjSlR7ljElqj3LmBLVnmVMibzyNKY09m5Kcs+mRAR7GlMGvc8wWPtkyoAIdhlTIoJdxpSIYJcxJSLYZUxJMOUqpsT7ymVMibxyGVPifeUypsT7ylVMOfcl3O+YMqlNZau1ev3D3tFWA/Mu3B/WF4RusCyz7/DCsswazgvLMushLyzLVJJZYVnmtnFmWJapcPLCsky1kBeWZSpvvLAQYMnBgig3Cwui3CwsiHKzsCDKzcKCKDcDS1rm5nhmWBDlZmFBlJuFBVFuFhYCLDlYEOVmYUGUm4UFUW4WFkS5WVgQ5eZg0Yhys7CIjHJdSpvKPukcLCKj3DosIqPcOiwEWHKwiIxy67CIjHLrsIiMcuuwiIxy67CIjHKrsBiRUW4dFpFRbnBhO30YPP0Ky/PT1prtlx96Tb86iJ/x9vuxxktS8fAwhW+8RYbPB+ItMi4/EG8C3kPxFplJHIi3yBTlQLxF5j4H4i0yqToQb5HZ2nF4W5FpYLBmn18gW8FbX5D7floHn+5PO5WDXG0dZe7Rkpdnb4DLTDAPBFxmhnkg4DJTzAMBJwA+FnCZSeaBgMvMMg8EXGaaeSDgMvPMAwGXmWgeBzgh0+QG3G8n9h6/c5J/lozbrEMm0nMhYJ3rn2cxT9wfjsFWnjXWbA8boup3aLS/f4dGpcrTFFXY0IsP35axXn+bHtGVWNMjzhNrekScYk2P2Feq6de57hqmf9f0ePMk1vR4BybW9HgbJ9b0BNNLNT2qeWJNj2reEqa/GRP1uYWMiYrbQsZEDe08xjzFhatpncvJQalZKIWaHyjFTCnUEkEpZkqhRglKMVOKQClQipdSqKmCUsyUQq0WlGKmFCrGoBQzpVC3BqWYKYXqOSjFS6mA6jkoxUwpVM9BKWZKoXoOSjFTCtVzUIqZUgRKgVK8lEL1HJRiphSq56AUM6VQPQelmCmF6jkoxUwpVM9BKV5KRVTPQSlmSqF6DkoxUwrVc1CKmVKonoNSzJQiUAqU4qUUquegFDOlUD0HpZgphboUKPUmpYy9U+rhNruNUgkZHyj1JqWC3kxogrXPlELGB0oxU4pAKVCKl1LI+EApZkoh4wOlmCmF81KgFDOlcF4KlGKmFOpSoBQnpYxSOC8FSjFTCuelQClmSqF6zkypZPT3w8m5yrNOhf2CXq0e9LjduXsxDyrRU5uHYJ6ZzYMK6dTmQbWRO5yJ2xXu+oJuLZ65X2BxecceavEM5x1EF9ujLCjX9qjfybU9Cm1iba9REZNre5Su5NoeNSa5tkcBS67tCbYXa3uU3uTaHnU9ubZHXW8N29+siUrdStZE7W0haxpU005kzTO0Z184hSodOMXNKVT/wCluTqGqCE5xc4rAKXCKmVOogoJT3JxCdRWc4uYUqrbgFDenUDsGp7g5hQo2OMXMKYs6OjjFzSnU0cEpbk6hjg5OcXMKdXRwiptTBE6BU8ycQh0dnOLmFOro4BQ3p1BHB6e4OYU6OjjFzSnU0cEpZk4R6ujgFDenUEcHp7g5hTo6OMXNKdTRwSluThE4BU4xcwp1dHCKm1Ooo4NT3JxCHR2cYuaUQ30KnHqXUy/vHr9wCnkfOPUupyo38jgCp8ApZk4h7wOnuDmFvA+c4uYU8j5wiptTOD8FTnFzCuenwClmTnnUp8Apbk7h/BQ4xc0pnJ8Cp7g5hfpUnVPe0M6pUKVJUvubi+Rs5WlSaqMgKXrg63ZVb0Bwwmwgq9R2lbJVsWpOa3avJ9I1r+e90yMgihBsfGz3go2P99uCjU8wvlzjIyIXbHy82hVsfLyDFWx8vCwVbHy81ZRr/IgKn2Djo8K3iPFv5kTNbilzogq3lDkJ5jyROc/R3RhRrwOp2EmFOiBIxU4q1BdBKnZSoW4JUrGTCvVQkIqbVAl1VpCKnVSo34JU7KRCFRmkYicVatkgFTupCKQCqbhJhYo6SMVOKlTUQSp2UqGiDlKxkwoVdZCKnVSoqINUzKTSChV1kIqdVKiog1TspEJFHaRiJxUq6iAVO6kIpAKpuEmFijpIxU4qVNRBKnZSoaIOUrGTChV1kIqdVKiog1TcpNKoqINU7KRCRR2kYicVgVQg1buken2rr9bI/kCqt0n1+ooLrZH9gVTspEL2B1Jxk8og+wOp2EmF7A+kYicVzlOBVOykwnkqkIqdVARSgVTcpMJ5KpCKnVQ4TwVSsZMKFXVuUmkVd0VcqDx9AWG3ZXwAb7vfVxtUpyc3ECq9cxvIomo6uYFQgWQ3UNgNZEzNQOZ+L8blBXyoBTasFxxpi0qhYOOjoifY+ATjyzU+KmSCjY9KlmDjo+Ik2PioZgk2Piplco1PqMIJNj4qfIKNjwrfIsa/mRM1u6XMSTDnSuZEXe1M5jxHLzehXgdSsZMKdUCQip1UqC+CVOykQt0SpOImlUM9FKRiJxXqrCAVO6lQvwWp2EmFKjJIxU4qAqlAKm5SoaIOUrGTChV1kIqdVKiog1TspEJFHaRiJxUq6iAVN6k8KuogFTupUFEHqdhJhYo6SMVOKlTUQSp2UhFIBVJxkwoVdZCKnVSoqINU7KRCRR2kYicVKuogFTupUFEHqbhJFVBRB6nYSYWKOkjFTipU1EEqdlKhTgVSvU2qyhXmAdkfSPU2qSq3+ARkfyAVN6kisj+Qip1UyP5AKnZSIfsDqdhJhfNUIBU7qQikAqm4SYU6FUjFTiqcpwKp2EmF81QgFTepksg6lUtphzu6GqlspP2m++jj/rTPMtDa7UYHbeP9onttdHaGG10p3sHQfrOOyILPaawjsnJyGuuILEGcxjoE60xsHZFJ8WmsIzK7PI11RKZpp7GOyBNEp7GOyKM401jH7XUF55+tYxRqBTNbB7WCQ60TNqVdSBnroFYws3VQKzjUOnsrgVc2Yx2CdSa2DmoFk1hH64x1UCuY2TqoFRxpHR+2X/ZRZayDWsHM1kGt4FDrxE0Pn+jZOhq1gpmtg1rBkdYJakMj6JixDmoFM1sHtYJJrGN8xjoE60xsHdQKZrYOagWHWmfXI6pczIZawczWQa3gSOvEfWWL2ZgNtYKJrWNQKzjUOtZu1iGTsQ5qBTNbB7WCSazjMjVqg1rBzNYhWOdA6yS9PZxy2ahBrWBm66BWcKh17PbLiTLnCgxqBTNbB7WCQ62zn6NOPreyoVYwsXUsagWTWCdkqqAWtYKZrYNawZHW0cptWmvlM/moRbVgbvsQ7MNrHzLbT2t6/FpT1j5Wh7vWD0CbkH1ahe3otVXxrojVLvd00FupyIaHWtHX0zfboxoh1/aodci1PSopcm2POo1c26MKJNb2hBqTXNujgiXX9qiPybU9am9ybU+wvVjbo64n1/ao68m1Pep6cm2Pup5c26OuJ9b2DnU9ubZHXU+u7VHXk2t71PXk2p5ge7G2R11Pru1R15Nre9T15NoedT25tkddT6ztPep6cm2Pup5c26OuJ9f2qOudyfb7B1EuBgwV20ft90+tGnW/rc3krRiU3Q2j71/Is15/M4XAFDDlR0xBzRBM+RlTUGEEU37GFNQjwZSfMQXVSzDlR0wJqHmAKTem7JBc/vQZphCYAqZ8YR3V9iUsujyeYQpyH4lMudke2Yxc2yM/kWt7ZBzL2t7ou+2dqUQH4W7FkJKtPG33r8zSQyRhKGvxtL30+brW9vHhGwNxagMMPJSBEWdHwMBjGYhqDhh4LANxjgYMPJaBOM0DBh7LQAIDwcBDGYgKPBh4LAPxHgAMPJaBeBsBBh7LQLwTAQOPZSDeiYCBhzIw4Z0IGHgsA/FOBAw8loF4JwIGHstAvBMBA49lIIGBYOChDMQ7ETDwWAbinQgYeCwD8U4EDDyWgXgnAgYey0C8EwEDj2SgVXgnAgYey0C8EwEDj2Ug3omAgccyEO9EwMBjGUhgIBh4KAPxTgQMPJaBqAeCgX0ZaOydgeSeGKiRC4OBfRkY9GZxE6x9ZiByYTDwWAYiFwYDj2UggYFg4KEMRC4MBh7LQJwPBAOPZSDOB4KBxzIQ9UAw8FgG4nwgGHgoAw3OB4KBxzIQ70QOZeAFj+2nbYgVBvLe3mQN3kbItT3eA8i1PcH2Ym2P2rdc26PqLNf2qPfKtT0qrXJtjxqnWNtbVBfl2h51Pbm2R11vDdvfrIlK3UrWJFhzIWuimnYia56jT9KiSgdOcXMK1T9wiptTqCqCU9ycQrUSnGLmFKEKCk5xcwrVVXCKm1Oo2oJT3JxC7Ric4uYUgVPgFDOnUEcHp7g5hTo6OMXNKdTRwSluTqGODk5xcwp1dHCKmVMOdXRwiptTqKODU9ycQh0dnOLmFOro4BQ3pwicAqeYOYU6OjjFzSnU0cEpbk6hjg5OcXMKdXRwiptTqKODU8yc8qijg1PcnEIdHZzi5hTq6OAUN6dQnwKn3uVU5VZfj7wPnHqXU5VbETzyPnCKmVMBeR84xc0p5H3gFDenkPeBU9ycwvkpcIqbUwROgVPMnEJ9Cpzi5hTOT4FT3JzC+SlwiptTqKMfyikyO6foi0cvOWWIdmNSvN9FrH1OkeQ2QC6IPcAXvi2PardQy0fUpKVaHpVjqZZHfVeq5VGFlWp5guWFWh4VTamWR93xWMurdLe8qVierDYbIPaBJxfL34yJgt9CxkSlbSFjoni2jjET6mELGRMlroWMiarVQsZEIWohYxKMuY4xUS5ayJioAC1kTFSAFjImKkAnMibdjXn5v0djZn46+L3gH7V9tjzKRTItTwq1JamWRyFKquVRtZJqeZS4pFqeYHmhlkfxTKrlUWmTanmU5aRaHjW8VS0fye5au/BsedTwhFpeo4a3rOW92bV+VGSzPGp4Ui2PGt6ylk+71km5Z8ujhifV8gTLC7B8JqvTqOFJtTxqeFItjxrePJb3FctrRXvbs/r1aF1mjvf7aJzR9Gx51PBWtbwhv1veZ7I61PCWtXzaLW/tcw3PoIYn1fKo4a1qeRu2hx093Du3Wx41vFUtT2FDzzn1vM8b1PCWtbz3d8tnVnuC5Re1vA+b1i7oSvIfvN1oEnx8Tv4NCn6gyQ9oguogaPIDmqCUCJr8gCaoO4ImP6AJipSgSZ0mFhVN0OSLG2k7sB6C1s80QfkTNPkBTVArBU2+uLFrHYJNzzRBYRU0+QFNCDQRR5Ob5VFYlWp51EqlWh7lT6mWR0VTquVRpBRqeULdUarlUUqUanlUB6VaHgW/VS0f9W756Eyl4Fd5GUkEmoAmdZqgOgia/IAmKCWCJj+gCeqOoMkPaIIiJWjyA5qgogma1A9KOZQ/QZMf0AS1UtCkflDKobAKmvyAJqjCCv16iSNYHgtEPdxAYRU0+QFNUFgFTX5AExRWQZMf0ASFVdDkBzRBYRU0qee4HoVV0OQHNEFhFTT5AU1QWBX6dXePWqm8BeJmeYLlhVoe5U+plkcNQqrlUVYQavmASoFUyxMsL9TyiPCkWh7vrKVaHrG9VMsjthdq+YjYflHLe222k65e++eTrhEv9pa1vKK75eOz5fGuTqrl8a5OquUJll/U8heoN8sb558tj0rOsj6/z/Fi+UyEh0qOVMujoUCq5VHDk2p51PC4La9iyfJXxBNqZ6MRR81qNOKoFdURT2rLwGwytoK43ncIrc1da6tdboZm+2Wi+/5gVe5Zu+eBlswvz94sidrPKpYkWHIRS6I2s4olUWtZxZKonaxiSdRCVrEkahtrWNIp1ExWsSRqMatYEjWeVSyJGs+hltRmtyRVLBnuOIeU7mqYLNDWbWc5ydzR+FIoY5P9ew3GaPP48I0jBI6AIxWOoC4FjtQ4gooXOFLjCGpp4EiNI6jSgSM1jqD+B45UOKJRWQRHahxBzRIcqXEE1VBwpMYR1FnBkRpHCBwBRyocQZ0VHKlxBHVWcKTGEdRZwZEaR1BnBUdqHEGdFRypcMSgzgqO1DiCOis4UuMI6qzgSI0jqLOCIzWOEDgCjlQ4gjorOFLjCOqs4EiNI6izgiM1jqDOCo7UOII6KzhS4YhFnRUcqXEE9RFwxNg7R8g9cwR5DTgS9KayCdY+cwR5DThS4wjyGnCkxhHkNeBIhSOEvAYcqXEE50fAkRpHcH4EHKlxBPURcKTGEQJHwJEKR3B+BBypcQR11h9whOLOkRBec8S6XWf98MPZe9fCPr9HKHT2d53abO68+eXZmx1RC13DjqhXrmFH1BSXsKND3W8NO6I2t4YdUT9bw46oca1hR4Idl7AjakUnsaPfnvUqVZ7VagdZq3i/VNn47+qPQ/VHotVRK/qB1eN+v5HWFatH7befjubBPvnqLcW95EzxoX5rvf62D2pAc9sHtZ2p7eNRs5nbPqjFzG0f1Fjmtg9qJ3Pbh2Cfqe2DWsfc9kFVYm77oH4wt31QPxhnnxviqAgMRjwgxx+NOLJ2ZsSNviPuTGXVP+xrHQHVAJl2R5VBpt0Jdhdpd1RFZNod1RaZdkcVR6bdUR2SaXfUqETaPaJSJtPuqNfJtDvqdTLtjnqdTLsT7C7S7qjXybQ76nUy7Y56nUy7o14n0+6o14m0e0K9TqbdUa+TaXfU62TaHfU6mXYn2F2k3VGvk2l31Otk2h31Opl2R71Oot29Qv6+pt1f31TsFcHuS9r99c0pXiGel2l3xPMy7Y54XqbdEc/LtDvev4u0u8b7d5l2R/4u0+54/y7T7nj/LtPuAuL520QFBLDXiZolIzZLr39Yx70urSPdr3kh/43KkvHMx6gsudt/jMqSe+HHqBBQyaCy5HuPj1FZ8q3Ax6gsWTP/GJUlI9CPUVkyXP0UFYvYNocKYtscKohtc6ggts2hQkAlgwpi2xwqiG1zqCC2zaGC2DaHCmLbDCqE2DaHyiqxrTV208Ka2g8ba7aHDZHeH86/DuK9MMvTKoHziSBfJSo/EeQEyEdDvko+cSLIV0lWTgT5KpnQiSBfJc06EeSr5HDngdytkiCeCHJkn8MhR/b5EeQ3EJFPMoBIAPFzEJHz1UE8xyc9HHLJZUyJHHUZUyL3XcaUyKlXMaVHrr6MKVEDWMaUqC0sY0pUOJYxJcGUq5gS1Z5lTIlqzzKmRLVnGVOi2rOMKVHtWcWUAdWeZUyJas8ypkS1ZxlTotqzjCkJplzFlKj2LGNKVHuWMSWqPcuYEtWeZUyJas8qpoyo9ixjSlR7ljElqj3LmBJ55WlMWbkONCKCPY0pKzdFRESwq5gyIYJdxpSIYJcxJSLYZUyJ95XLmJJgylVMibxyGVPifeUypsT7ymVMuUy1x1qzmdImXTHl/Rs4l3JYqJmS93NZaZmqzFkgD2qZ6sl5IF+mynEeyJepRpwH8mWqBueBnAD5aMiXycLPA/ky2fJ5IF8mqz0P5Mg+h0OO7PMjyK8gauSTDCAiQ2QAETlfHcRTnKEMGrnkMqYkmHIVUyL3XcaUyKmXMSVy9WVMiRrAMqZEbWEVUxpUOJYxJeosy5gS1Z5lTIlqzzKmJJhyFVOi2rOMKVHtWcaUqPYsY0pUe5YxJao9q5jSotqzjClR7VnGlKj2LGNKVHuWMSXBlKuYEtWeZUyJas8ypkS1ZxlTotqzjClR7VnFlIS88jSmfP2x5kCIYE9jytdfYgqECHYZUyKCXcaUiGCXMSUi2FVM6fC+chlT4n3lMqZEXrmMKfG+chlTEky5iimXqfaQ2n7YkqPHH75NdJmsqzbRZXKSykT9KhE76bCtQqQfnD//w+WHb6isEvzyorJKHPkWKj66rdTvY7hvb/4blFUiMlZQCKA8g7JKlPAeKEltKvtkwhMoq7xdYQVllfcUrKCsEnuygrJKnMoJShAZ09ZAERnS1kCRGdFWQJEZ0VZAIYDyDAoi2gwoiGgzoCCizYCCiDYDCiLaZ1AiItoMKIhoM6Agos2Agog2AwoBlGdQENFmQEFEmwEFEW0GFES0GVAQ0T6DkhDRZkBBRJsBBRFtBhREtBlQCKA8g4KINgMKItoMKIhoM6Agos2Agoj2CZSoENFmQBEa0dJ+EDC5Z1CERrSvQREa0b4GhQDKMyhCI9rXoAiNaF+Dcs7g7ao7bp0+T3ugVduzxmp6fPhmylVWcZgSt06vY0p812sZU+K7XsuYEt/1WsaU+K7XKqbErdMn+jJtMrsplXs2Jb7rtYwp8V2vZUyJas8ypiSYchVTotqzjClR7VnGlKj2LGNKVHuWMSWqPauYElcVr2PKZcIeYzctrKn9sLFmNyWRPokpKzXYda5fhCmXCXtgymXCHvGmpGVecsGUy0SwMOUyL7lgymVecq1vykpeSQRTrmLKZV5ywZSo9ixjSlR7ljElqj3LmBLVnlVMuc5VxTAlqj3LmBLVnmVMSTDlKqZcJewxSW0qW63V6x92Ke1wR3eHW3/dAPwMd4ph00Prh09R2PMWbJe5HBZ2f8/uqwRUsPt7dl8l+oLd37P7Ki/mYPf37E6wu0i7r/LKD3Z/z+6rvB+E3d/K35e5Txx2f8/uq7x5hN3fszvqdSLtvszF97D7e3ZHvU6m3VGvk2l31Otk2p1gd5F2R71Opt1RtxFp94i47gd2V5vdbTL2td0vsrcJam3uWlvtcjPU+w009PCscjPV8iNiQHCkxhECR8CRCkcQW4IjNY7gvTE4UuMIchVwpMYRvI8GR2ocwbtrcKRSH0l4zw2O1DiCd+LgSI0jqLOCIzWOoM4KjtQ4QuAIOFLhCOqs4EiNI6izgiM1jqDOCo7UOII6KzjymiMXYMERcKTCEcSsdY5E0ttPRx8rHKH962Cawh06bXTupy94bD9tw/2nTcg9fY4e9KQQ44JT3JxCTAxOcXMKMTQ4xc0pnG0Ap5g5pZHHgVPcnMLZCXCKm1M4awFOMdenNM5mgFPcnCJwCpxi5hTq6OAUN6dQRwenuDmFOjo4xc0p1NHBKW5OoY4OTjFzyqCODk5xcwp1dHCKm1OoeYJT3JxCjH4op3S4a/0AdJ5TVtldEe3uH7zMnzM+ydtBg4geDDyUgRbxPxh4LAORLYCBxzIQZ3TAwGMZiOwWDDyWgQQGgoGHMhCnhcDAQ+uBFmeLwMBjGYiTSGDgsQzEOxEw8FgG4p0IGHgoAwnvRMDAYxmIdyJg4LEMxDsRMPBYBuKdCBh4LAMJDAQDD2UgKtJg4LEMRDVmWQZqf2egShVOfVnjbpi7JtbrG1McqiZgyhXrqGkDO+qUYQqqG2DKjSnG7kyxJsMUVCHAlJ8xBdUCMOVnTCEwBUz5EVNwIhFM+RlTUKcBU37GFJzwA1N+xhScxANTbkzZr2O7kEZlmIIaLZjyI6Z41GjBlJ8xBTVaMOVnTEGNFkz5GVNQowVTfsYUAlPAlB8xBTVaMOVnTEGNFkz5GVNQowVTfsYU1GjBlJ8xBTVaMOVHTAkkkSnBmn1+gWpM0d5sR0x1eDS+U3njb1pbY0LlaXM3pzE2VMx5ko9rBZFpEkjVl1QiMyqQqi+pRCZfIFVfUonM00CqvqQSmdKBVF1JFUWe0AGp+pJK5GEekOozUlW+DBBFnvsBqfqSSuQRIZCqL6kIpAKpuEmFijpIxU4qVNRBKnZSoaIOUrGTChV1kIqdVKiog1TcpEqoqINU7KRC8ROkYicVAnVuUim1H+RVsfa0sfuRYkOkT0Kqyru/hEAdpGInFQJ1kIqXVBcAEKiDVOykwtEXkIqdVMj+QCp2UuHoC0jFTioCqUAq1jrVBQAcfQGp2EmFoy8gFTupUFEHqdhJhYo6SMVOKlTUQSpuUmlU1EEqdlKhog5SsZMKFXWQip1UqKiDVOykQvETpOImlUGgXidVUG4nlU8VmsS43a6nL6XlGqfW++jLhVOI08Epbk4hTAenuDmFKB2c4uYUgVPgFDOnkPiBU9ycwqEXcIqbUzjzAk5x16dw5AWc4uYUTryAU8ycsqijg1PcnEIdHZzi5hTq6OAUN6dQRwenuDlF4BQ4xcwp1NHBKW5OoY4OTnFzCjVPcIqZU4QYnZtT+8Mx2BqlVvzCCxEoBUrxUgoROijFTCkE6KAUM6VwzgWUYqYUUj5QiplSOOUCSvFSyuGQCyjFW5dyOOMCSjFTCkdcQClmSqF6DkoxU4pAKVCKl1KonoNSzJRC9RyUYqYUquegFDOlUD0HpZgpheo5KMVLKY9SJyjFTKllwnNH2w8bl+LrH9Yxbcd5jbKLvFvzy4TFMOUy4ShMuUwYKN6UYZnDCzDlMpE0TLnMy3qYcpmX5OubspJXBoIpVzHlMi+FYUpUe5YxJao9y5gS1Z5lTIlqzyqmjKj2LGNKVHuWMSWqPcuYkmDKVUzJkIwEt+FCSdnXDzsXNrPHR+u4HOAque2O1svf/g65/1Y+nln5NLXyO9e1Vg+8+VY+qTMrr8+svDmz8nZi5S8Kp7vyxj8on1FDp32buWxPTxMlKRN1UibqpUx05oiAdaIzRw+sE5050mCc6OWnpt4bdzX0L1+i3ZSfOyqpKD93VFJRfuaopKo8nVn5maOHqvIzRwRV5efO+yvKz533V5SfO+9/rbw+8w6rz7zD6jPvsPrMO6wevc6brW7oKNaVf1ll1DqcWfk4tfIva11apxMrb9SZlddnVt5MrDxnsm6slImSlIk6KROdOSJgnejM0QPrRGeONFgnOndU8joSt3NHJRXl545KKsrPHJVUlZ850qgqT2dWfuaIoKr83Hl/Rfm58/6K8nPn/RXlz7zD0pl3WDrzDktn3mE57u7zZo9bg6ocCNYUaNPH6YfPf6Xc0562h73TD8/Gb+X91MqH7WCwjy6jfJhbeb0r7zPKxzMrn06sPMdtPscpr8+svDmz8vbMytPUyvutT8P7mFF+7h22ovzcO2xF+bl32Iryc++wFeXn3mFfK+/n3mErys+9w1aUn3uHrSg/9w5bUf7MO6w/8w7rz7zD5jtOnNmaXJ25v8b67lvV+eaNypj09hiTbymojNENY0zDGNswhhrGuIYxvmFMaBiT54HfeO8eTpXtY9L7Y/IHXytj8jxIezVKm+cxpmGMbRhDDWNcwxjfMCY0jIkNY9L7Y/IH4ypjGnhgGnhgGniQf6Vugt6/ixCsfR6VndFlF9qPtvn47A/5l8jVUbZpFDWNyjJch7AtQfrx8xP7KN80KjSNik2jUsuo/Mug6ijdNMo0jbJNo6hpVBM3qIkb1MQNauIGNXHDNXEjX7nVSW/xoU4mM8q0jMqHxCaGrTXAJJ32UT53I02MtFUUYwq+8vAlg9gevoQYd33y0XZUmx4UHz7iYi9xxE39cG7147nVT6dWP3/fwXnU1+dW35xbfXtu9enc6rtzq3/uXTece9cN5951w0S77lWhONE+elNoop3xptDovW6SzyrqvapyKe88l1WiBSw5WAiw5GBxgCUHiwcsOVgCYMnBEgFLDpYEWDKwJAVYcrBowJKDBVFuFhZEuVlYCLDkYEGUm4UFUW4WFkS5WVgQ5WZhQZSbgcUqRLlZWBDlZmFBlJuFBVFuFhYCLDlYEOVmYUGUm4UFUW4WFkS5WVgQ5eZg0Yhys7AIjVuMvcNC7hkWoTvR65YOq4XuRDVYhO5ENViE7kQVWIzQnagGi9B6Sw0WofWWGixC45YaLARYcrAIrbfUYMlGuZfq1Dbq6/7L1zPVOtr7Vx+THnoW3OY/PX+mCcSzTyCdfAL53vYzTUCffQLm7BOwZ58AnX0C7uwTOPtObKfaiW8qTbW33lSaare8qkTj979zVMZJA5g8MAbA5IGxACYPDAGYPDAOwOSB8QAmD0wAMHlgIoDJA5MATBYYh8i3AAwi3wIwiHwLwCDyLQBDACYPDCLfAjCIfAvAIPItAIPItwAMIt88MB6RbwEYRL4FYBD5FoBB5FsAhgBMHhhEvgVgEPkWgEHkmwcmiI1jKu1LQeyuVDnxGsTuSjVgxO5KNWDE7ko1YMTuSjVgxNZjasCIrcdUgIli45gaMGLrMTVgxNZjasCI3a6t2p41VtMzMGK36xowYrfrGjBit+sKMEnsdl0DRux2XQNG7HZdA0ZsocokswOjnit4SWyhqgaM2EJVDRixkW8NGLGRbw0YsZFvDRixke9rYEjJfeFWAUZs5FsDRmzkWwOGAEweGKFfDXydKZHU79fWYBH61cAaLEK/GliDRehXA2uwEGDJwSL0q4E1WIR+G7sSt0j9NnYNFqHfxq7BIjTKrcAi9dvYNViERrk1WIRGuTVYpN7pUYGFAEsOFqFRbg0WhHM5WPJfGzZpH2WVupctNYXvYalpWP7jlPVhbUrmP2xYH2bbhlHbMNc2zLcNC23DYtuwNpa4Npa4Npa4Npa4Npa4Npa4Npa4Npa4Npa4Npa4Npb4Npb4Npb4Npb4Npb4Npb4Npb4Npb4Npb4Npb4NpaENpaENpaENpaENpaENpaENpaENpaENpaENpaENpbENpbENpbENpbENpbENpbENpbENpbENpbENpbENpakNpakNpakNpakNpakNpakNpakNpakNpakNpakJpY4pdqG6bZhpm2YbRtGbcNc2zDfNiy0DYttw9pYottYottYottYottYottYottYottYottYottYottYYtpYYtpYYtpYYtpYYtpYYtpYYtpYYtpYYtpYYtpYYttY0lb6c7aNJbaNJbaNJbaNJbaNJbaNJbaNJW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1bbVX11Z7dW21V9dWe3VttVfXVnt1pa7rtPe3Ge1+GZY55bKJCGF/cv/92Pn3U9ff96VWWrbf151/33T+fdv596nz77vOv+87/37o/Pux8+939l/d2X91Z//Vnf1Xd/Zf3dl/dWf/1Z39t1AuDz5+jzEh0tO27fMVzaC2z42Hh8+w621MaBiTdf9g7TaG0vOYlB+zo+Dt05h8FTPEDeWQwvMY3TAm607RbAdvIz1jkC9eRrOfA3b+eUzWrHFnQszp5l6PSRn75HM6rfavb2rl71Hf9+lgn0/paqPyGZ3WOxm0dvp5lG4aZZpG2aZRlB/l3T4qZtDIepMmtX/qgVRGVmwalVpG5XOr6qi8vS6vA7dRl2Ly8yjTNMo2jaKmUa5plG8aFZpGxaZRqWFUyKc11VG6aVSBG/vCpi+J+fMo2zSKmka5plG+aVRoGhWbRqWWUfmQVlu9j7JWP48yTaNs0yhqGuWaRvmmUaFpVGwalVpG5c+gVEc1ccM0ccMUuEFhH+WfVxtDTaNc0yjfNCo0jYpNo1LLKNsSOYT8wZPqKNM0yjaNKmQme8ZAT1+qD/mMIdEelTv3PMY2jKGGMa5hjG+I/UP+kEN1VGwa1ZKdhPwJh+oo3TTKNI2yTaOoaZRrGtXEDdfEDdfEDdfEDd/Ejfz5hNerRf5wQtprLMlkxjR4fv6gQEVObBiT3h+TPx9QGaPfxyA0rMyhYWUODfYJDStz/jRAZUxoGJPnwf5FyxSec4J8xej1mHy9qDJGN4wxDWNswxhqGFPjQW5MAw9iAw/ytajKmPT+mHwdqjKmYT1IDetBalgPUsN6kBrWg9TAg9TAg9TAg/Q+D6J6kweXf+ivB/ORsdPbRzsea06X2saXsHxg/HqIf39IeH9IfHPI5V/m68l8Wuv3YCQ+fAREO/slK5/Tvh7i3x8S3h8S3x+S3h6ST2Kj2YdQfBqi3x9i3h9i3x9C7w9x7w/x7w8J7w+J7w9Jbw/Jv1CMcQtCY0q/DMl8jWd//3NJSfdnL6/prj+v+/686fvztu/PU9+fd31/3vf9+dD35yPjz0f79POp68871ffn81Hl/vY/2fD7OpIv9bweYt8fQu8Pce8P8e8PCe8PiW8PKVQZXg0pFBleDskfGt6/0GZ8+J0wheaDl0Ps+0Po/SHu/SH+/SHh/SH54+MPn+N78spCg8GrIYXmgpdD9PtDzPtD7JtDLv+y1/g+q57f+ew9/Z5L5N+qvR5i3x9C7w9x7w/xbw65/Iu+nix9lMDoHfHH42aXMu/XUHcdqgvJf4h7Rmoez/blL3dJdD9dlIh+ef4yM61piBQ3RIpnkRLSXUpUz1LCEClxiJQ0QopRQ6ToIVLMECl2iBQaIsUNkTLE980Q3zdDfN8M8X3L4fvm4V2oUSYjRQ+RYoZIsUOk0BApbogUP0RKGCIlDpGSRkihIb5PQ3yfhvg+DfF94vF99yDFZ6S4IVL8EClhiJQ4REoaIcWpIVL0EClmiBQ7RMoQ33dDfN8N8X03xPcdj+8nd5eS/LOUNEKKV0Ok6CFSzBApdogUGiLFDZHih0gJQ6QM8X0/xPfDEN8PQ3w/sPj+JT3dpejH936bFDtECg2R4oZI8UOkhCFS4hApaYSUqIZI0UOkDPH9OMT34xDfj0N8P/FwzKu7lGCfpbDYJYS7lBD0sxQaIsUNkeKHSAlDpMQhUtIAKUapIVL0EClmiBQ7RAoNkeKGSPFDpLD4flRxlxJVepYSh0hJI6RoNUSKHiLFDJFih0ihIVLcECl+iJQhvq+H+L4e4vtmiO8bHt+ne8wfKTxLMUOk2CFSaIgUN0SKHyIlDJESh0hJI6TwnLmqShni+3aI79shvm+H+D7Pmat4P9dn4vO5PsNz5qoqJQyREodISSOk8Jy5qkrRQ6SYIVLsECk0RMoQ36chvk9DfJ+G+D7POaWk9i8SmqTtsxQOjtnLortJscZl5uKGSPFDpIQhUuIQKWmEFJazPXUpeogUM0SKHSLlbd+/jnJNo3zTqNA0KjaNSi2j3j+7ch2lm0aZplG2aVQTN0ITN0ITN0ITN0ITN0ITN2ITN2ITN2ITN2ITN2ITN2ITN2ITN2ITN2ITN2ITN1ITN1ITN1ITN1ITN1ITN1ITN1ITN1ITN1ITN1ILN6xSTaN00yjTNMo2jaKmUa5plG8aFZpGxaZRTdzQTdzQTdzQTdzQTdzQTdzQTdzQTdzQTdwovB90+2Gy5AI9j0otowrv72qjdNMo0zTKNo2iplGuaZRvGhWaRjVxwzRxwzZxwzZxwzZxwzZxwzZxwzZxwzZxwzZxwzZxwzZxg5q4QU3coCZuUBM3qIkb1MSNQn3b718Wu/zpn0eFplGxaVRqGVXoya2N0k2jTNMo2zSKmka5plFN3HBN3HBN3HBN3CjUdQNtH7fUyvxyQ3euTOnU/h7EaR2ehegRQswIIXaEEBohxI0Q4jmEOLM97pJ6KIF/3Y7y9LT328sy/3B7ik7xplCYTaE4m0JpuEKk47Yvk/Ppl6e/VApqPpX0fCqZ+VSy86lE86nk5lPJz6dSmE+lOJ9K863ecb7VO863esf5Vu843+od51u943yrd+y9el+FhBFC4gghLGtmMmYX8nBt8CYkqRFCNLuQ+CzEjBBiRwhhWU1S2tMppTI2cSOEcFDYX57ZhTw2GNyEkOIwvI9ue9zHEJ+FvG/46zBqG+bahgUWuL3e4X6sRn8joTlWDH8p8W9C7MOtjrsQzSJEx5dCzAghdoQQGiGEY8XwF25vQshk2OVHCAkjhMQRQtIAIUaNEKJHCGHxeAp3IUk9C7EjhNAIIW6EEB6P9/EuRD8LCSOExBFC0gAhVo0QokcIMSOEWHYhzxGopRFC3AghLB7v7gF7pthANowQEkcISQOEEIvHO7tnai7UykVOb9dnOfOgUPpWSM+mkJlNITubQnSkQqSeFXKzKeRnUyjMplAcrpAPeyki+meF0mQKOTWbQno2hcxsCtnZFKLZFHIHKLSnpdE9K+RnUyjMplCcTaHZVmo/20rtZ1up/WwrtZ9tpfazrdTezabQbCu1n22l9rOt1D5NplCYbaUOs63UYbaVOsy2UofZVuow20od/GwKsazUIe5nYKJ+fr/Fchq3KoRlRQ0PZ2Ayb09ZTsxWhegRQswIIXaEEBohxI0Q4kcICSOExBFCWDy+cuqN5XRoVYgeIWTEIUGW06FVITRCiBshxI8QEkYIiSOEDPB4p9QIIXqEEDNCiB0hhEYIcSOE+BFCwgghcYSQER6vR3i8HuHxeoTH6xEer0d4vB7h8XqEx+sRHq9HeLwe4fFmhMebER5vRni8GeHxZoTHmxEeb0Z4vBnh8WaEx5sRHm9HeLwd4fF2hMfbER5vR3i8HeHxdoTH2xEeb0d4vB3h8TTC42mEx9MIj6cRHk8jPJ5GeDyN8Hga4fE0wuNphMe7ER7vRni8G+HxboTHuxEe70Z4vBvh8W6Ex7sRHu9GeLwf4fF+hMf7ER7vR3i8H+HxfoTH+xEe70d4vB/h8X6Ex4cRHh9GeHwY4fFhhMeHEc4YWK4FTXY7BHv5m6jyvDVp+3Vr9f1pf9MozaZRVAdoZH3aNYrhQaPnZ0nv2pPR4Xft9am1N6fW3p5aezq19u7U2vtTax9OrX08tfbpzNqnU++16dR7bTr1XptOvde+fwXpVNqfeq9Np95r06n32nTqvTadea/16sx7rVdn3mu9OvNe69WZ91qvzrzXenXmvdarM++1Xp15r/XqzHutV6fea/Wp91p96r1Wn3qv1afea/Wp91p96r1Wn3qv1afea/Wp91p96r3W8Kz3+93pl78fby0he5PCsy7HbdLaKhWepdAQKW6IFD9EShgiJQ6RkkZIsWqIFD1EihkiZYjv2yG+b4f4vuXwfav2r25d/o7pWUoYIiUOkZJGSCE1RIoeIsUMkWKHSKEhUtwQKUN8n4b4Pg3xfWLxfb0f/bz8nYlgnRoiRQ+RYoZIsUOk0BApbogUP0RKGCIlDpEyxPf9EN/3Q3zfs/i+sWGXYpx6lmKHSKEhUtwQKX6IlDBEShwiJY2QEtQQKXqIlCG+H4b4fhjilTwdPzrtUky9C+llf43n6fjh1Iin4+dNjdjq3zwdP4dpb06tvT219nRq7d2ptfen1j6cWvt4au3TmbVPp95r06n32nTqvTadeq/l6fg5TPtT77Xp1HttOvVem06916Yz77VBnXmvDerMe21QZ95rgzrzXhvUmffaoM681wZ15r02qDPvtUGdea8N6tR7rT71XqtPvdfqU++1+tR7LU/Hz2Han3qv1afea/Wp91p96r1Wn3qvNafea82p91pz6r3WnHqv5ekOO0z7U++15tR7rTn1XsvTsWYM3bW3v2p/laKHSGFZP02MuxSr9bMUlnXOuHtHr4nuWQoNkeKGSPFDpIQhUuIQKWmEFFJDpOghUswQKUN8n4b4Pg3xfZaONWOdvq/J8XlNZulYq0uJQ6SkEVJYOtbqUvQQKWaIFDtECg2R4oZIGeL7bojvuyG+z9KxZojuESyF5ziZpWOtLkUPkWKGSLFDpNAQKW6IFD9EShgiJQ6RMsT3wxDfD0N8n6VjzTi6R7AuPK/JLB1rdSk0RIobIsUPkRKGSIlDpKQRUnh68apS9BApQ3w/DvH9OMT3eXq6vN6/TmX8c09s4Om9qkoJQ6TEIVLSCCk8vUFVKXqIFDNEih0ihYZIGeL7aYjv8/RsBGV3KUGnZylxiJQ0QErk6VWoStFDpNgRUvInMUxK5nuYVb+8ow3XUfl3qdVRumlUm4a2aRQ1jXJNo3zTqNA0KjaNSi2jqIkb1MQNauIGNXGDmrhBTdygJm5QEzeoiRvUxA3XxA3XxA3XxA3XxA3XxA3XxA3XxA3XxA3XxA3XxA3fxA3fxA3fxA3fxA3fxA3fxA3fxA3fxA3fxA3fxI3QxI3QxI3QxI3QxI3QxI3QxI3QxI3QxI3QxI3QxI3YxI3YxI3YxI3YxI3YxI3YxI3YxI3YxI3YxI3YxI3UxI3UxI3UxI3UxI3UxI3UxI3UxI3UxI3UxI3Uwo2kVNMo3TTKNI2yTaOoaZRrGuWbRoWmUbFpVBM3dBM3dBM3dBM3dBM3dBM3dBM3dBM3dBM3dBM3dBM3TBM3TBM3mqpzyTRxwzRxwzRxwzRxwzRxwzRxwzRxo6kumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qKpqS6amuqiqakumprqoqmpLpqa6qJaNRVGL8N02zDTNsy2DaO2YVmGWJX2b1MY7X4Z9nwWK2wiwv3LFPvv+86/Hzr/fuz8+6nv7+frvYy/rzv/vun8+7bz71Pn3+/sv7qz/+rO/qs7+6/u7L+ms/+azv5rOvuv6ey/prP/FirkwW9noU2I9Ou2ffmX/3o2H+qSdtu5aNLh4eh9yn1YygRldkHmfpmov71G6i3A9BZgewug3gJcbwG+t4DQW0DsLSB1FqCV6i5Bd5dgukuw3SVQdwmuuwTfXULoLiF2l9Ddp3V3n9bdfVp392nd3ad1d5/W3X1ad/dp/bZPX0fFplGpZZRRTaN00yjTNMo2jaKmUa5plG8aleeGsVsORMb5j9iXP8nEKiH1lpA/IcUqQXeXYLpLsN0lUHcJrrsE311Cd5+23X3advdp6u7T9LZPX0eZplG2aRQ1jXJNo3zTqNA0KjaNSi2jXGFewe2jQmZUXpaNahtFD9+C30blT1VVR+mmUaZpVIFRaR9lUnwe5ZpG+aZRoWlUbBqVWkYF1TRKN40yTaNs06gmboQmboQmboQmboQmboQmbsQmbsQmbsQmbsQmbsQmbsQmbsQmbsQmbsQmbsQmbqQmbqQmbqQmbqQmbqQmbqQmbqQmbqQmbqQmbqQWbhilmkbpplGmaZRtGkVNo1zTKN80KjSNik2jmrihm7ihm7ihm7ihm7ihm7ihm7ihm7ihm7ihm7ihm7hRqJZas1cVrf01C3jOkn2i7WIon9xvN1yZQmWVUwIxSIhulxAfvt76LcF1l+C7SwgcdlBut4N5skPsLiH1llCoBHNK0N0lmO4SbHcJ1F2C6y7Bd5fQ3adtd5+23X2auvs0dfdp6u7T1N2nqbtPU3efpu4+Td19mrr7NHX3adfdp113n3bdfdp192nX3addd5923X3adfdp192nXXef9t192nf3ad/dp313n/bdfdp392nf3ad9d5/23X3ad/fp0N2nQ3efDt19OnT36dDdp0N3nw7dfTp09+nQ3adDd5+O3X06dvfp2N2nY3efjt19Onb36djdp2N3n47dfTp29+nU3adTd59O3X06dffp1N2nU3efTt19OnX36dTdpxOLT794L2qV6i5Bd5dgukuw3SVQdwkFny6f5f3jraevMvwAGeFzGS/fgtvCuRtOCam3BK0YJLxam6zW3SWY7hJsdwnUXYLrLsF3lxC6S4jdJaTeEkx3nzYsPv1qFzKmuwTbXQJ1l+C6S/DdJbztcV9fPgpfz+YXHK3V3k91+fvxoGK8jo3Xsdml5OtDdttQZR8+6HT7TFNsGJPeH5N34MoY3TDGNIyxDWPo/TH5I1VBbUwK2vw+wr89IsuBYLdYOlD6fUTMj9i/7OXt7yOy9g9x6xMMKfw2In/E6OWIrO2j8d8jIv0+8/wRoGg2v4mPzYu3EVm7x/2bZvFZK3o9Iv1mj8s/0kuvNnenjj/zMk33hcD/MqM/3l82vkLl//5L6cjlxjKKD0z2dFvi3h9i3x9C7w9x7w/x7w/JeplzGzudfx4S3x+SZYAL2y7iQvp9SN7RXg/JWt+lfX9T9mmIeX+IrQzR+mkIvT/EvT8ka30f9J5gqqch4f0hWetf8tg9iKCnIentIflTX6+H6PwOs6/MOj4NMe8Pse8PocoQ45+GuPeH+PeH5HfYtO8z6hnk+P6Q9PaQ/PmguM8lPoOcP/Dzeoh5f0h+n91jkl/28u8h9P4Q9/4QXxninhw5f6zl9ZD4/pCs9ZMOW5zxTMv8SZLXQ/T7Q7LWT3Zb+hI9LbD5wxuvh9D7Q7LWT/v2mvzzXPz7Q8L7Q2JlSHhy5PwRhZdD8mcOXg8pZFdO7RmMfyJmNC2D7NuDvmJT/fVwPjcLNu6Zw2PYZDNBsFP3EMv88uw/ldI4vp93fX/e9/350PfnY9+fTx///P6laq9S5dmvGzh2Nj88bb5DeTWTMnqsMpp2ZYx9UsbMpIwdq8z+w1pReFKGZlLGHaaMc0/K+JmUCTMpE8cqE9KuTIxPyqRplPmKJ0y5Rm683hZM4/2jpO86mf16uFCQ2Eu+7jGQd+FFQeLlEP/+kPD+kPjmkC8U6BqRFYo/e73YPeB3Yeg//d/LP//ff/mPv/7Lv/7t3//zMuTrf/0/f/+3//rrP/7+/c//+v/+9/a//Ot//PVvf/vr//rn//0f//i3f//z//zHv//z3/7xb1//21/U9//7n9Y794f1wX9R7OvfxtEfl7c69E+3gub/NJfatbHhn24x5Nfz5vK8o+scrgXPr/+q/yC9jbhEos59/c83jnz9J2/+8PtPXArVSX/973YbbtIfNm3DSf1B1+G0D9f+D3Md4Ta1L6uq+eMS6dpvtWP4I4XtF+Ilkola7/K0ufyT9vswrtMme5kFfY++FJvirr69TMZav0/4oo8lc3+ndBWf/jB0f1V0xSleRt1r1Nf/FC5I3ivD1/+WwkVtcw/Jb1O2f1B8cKtfRGj7GmV9x+lSnrfqQpELTf5/",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14466155340988305413": {
            "error_kind": "string",
            "string": "caller is not a minter"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "8359297168692325491": {
            "error_kind": "string",
            "string": "Function is_minter can only be called statically"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "9171385800979035582": {
            "error_kind": "string",
            "string": "Invalid partial note"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "_store_nft_set_partial_note",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "11988194033336150524": {
            "error_kind": "string",
            "string": "Function _store_nft_set_partial_note can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "partial_note",
            "type": {
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "types::nft_note::PartialNFTNote"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHxgAAwACgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw0AAQACJiUAAACXHgIAAgAeAgADADM4AAIAAwAEJwICAQEkAgAEAAAAbyUAAADAHgIAAgEeAgADAAo4AgMEJAIABAAAAIslAAAA0icCAgABMAwAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAC/KgEAAQX3ofOvpa3UyjwBAQImKgEAAQW+Hj//PqT2+jwBAQImKgEAAQWmXp71B3Vp/DwBAQImLgAYyhjK",
      "debug_symbols": "1ZXdioMwEIXfJddeZJKZZNJXWZZi27QIosXahaX03Tcp/tW661Kk0Btx5BvP8ZhkLmLnN+fDOiv25UmsPi4iL7dpnZVFqC7XRGyqLM+zw3r4WMh4sXTjT8e0iOWpTqtarABZykT4Yhfvnabwjn2W+1BpdU0eealUi0tUPa3cBI0GqaHREHY06wmYkV0DM0kawp+JYLmMfddqAIB7of2F0ifu0ue59IGsbWmj9d/2Hdn2W50BHtl3emn7oO7tRxF+gQhI8woVgEkVTdi1aTJmRgUZWhxZmZkFSGS6BWhh9AcBzC+OrOodOTXnaLktAeo/GTm8c3TrM8/1aXyyz031MXRJMAz+ZAzlEZaqXV08PDYnY7OsdANbtjMZA6DpjzQCOU4Z8W3dX0P1lVZZusl9M9/252I7GHf199GPJt+xKrd+d658nIH9+IM4PxQnWt82Qyg0JtoEjaDzAw==",
      "brillig_names": [
        "_store_nft_set_partial_note"
      ]
    },
    {
      "name": "public_get_name",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAARSUAAABGLgQAAYBEKAIAAgSARCcCAwQBOw0AAgADJiUAAACbHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQo4AQIDJAIAAwAAAIslAAAA1icCAQADLwwAAQACLQwCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF+0Le07wSjQI8AQECJi4AGMoYyg==",
      "debug_symbols": "7ZXbisIwEIbfJde9mMlMTr7KskjVKoXSSq0Li/jum0hTaw12EfHKm9Ip3+SfzKFzEptiddwty3rbHMTi6ySqZp13ZVN763TOxKotq6rcLcefBYSHURf+sM/rYB66vO3EAtkCZKKoN+HdkfJnbMuq8BbJc3bPg5QRB5ZXWroEzZpVT7NWPNCWErBl63rYKlBj+DsTFl4TvosaiOjeGP6Lsq/skH07l31UxkRaEz0O3ykT7+o02kn4jl4dPsrb8IOIfYMIgn6HCmJaBQwOKuBoRsV4pMeNb92ZCkrWsYJSu0kFEfV/Irq9d/CT+KTfk3rET/q5lB8DDiMMdK1TmOY7mBTHnxvp0QijhVQLSBuPRhrRElO0UTo2jFF2ppSGdJxcw6Afw4g+2KEXydG08syfzCQyc/bWT96W+aoq+u25Pdbr0TLtfvfFZK/u22ZdbI5tETbsdbli2E7SZcSXUfMGqYyM1/A6fw==",
      "brillig_names": [
        "public_get_name"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "NFTNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "token_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "NFT"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_nfts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nft_exists",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_owners",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::NFTTransfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::owner_of_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::owner_of_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finalize_transfer_to_private_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finalize_transfer_to_private_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_store_nft_set_partial_note_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_store_nft_set_partial_note_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::prepare_private_balance_increase_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::nft_note::PartialNFTNote"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::prepare_private_balance_increase_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "approve",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_minter_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::cancel_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::cancel_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finish_transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finish_transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "types::nft_note::PartialNFTNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::finalize_transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::finalize_transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "minter",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::is_minter_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::is_minter_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_admin_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "116": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "119": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "121": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "125": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "129": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "132": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "133": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "134": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "135": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/storage/mod.nr",
      "source": "use std::{collections::umap::UHashMap, hash::{BuildHasherDefault, poseidon2::Poseidon2Hasher}};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "139": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "141": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "143": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes: BoundedVec<RetrievedNote<Note>, 16> = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            // We're not constraining note existence so we just drop the metadata\n            notes.push(notes_array[i].unwrap_unchecked().note);\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "147": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "148": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteType;\nuse dep::protocol_types::traits::{Packable, ToField};\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteType + Packable<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "150": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "154": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "156": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "157": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "162": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "163": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "164": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "167": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "168": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "169": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "171": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "173": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "178": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // docs:start:insert\n    pub fn insert(self, note: Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "181": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "195": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "196": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "197": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "198": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "199": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "200": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "201": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "202": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "204": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "206": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "207": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "210": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "228": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "264": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "271": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "286": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "288": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "289": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "29": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "290": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "299": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "303": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "305": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "306": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "315": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "326": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "340": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "344": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "345": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "361": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "362": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "364": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "369": {
      "path": "/Users/sebastiansalazar/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "376": {
      "path": "/Users/sebastiansalazar/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "378": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "54": {
      "path": "/Users/sebastiansalazar/Documents/aizktec-Core/aizktec/packages/aztec/contracts/nft_contract/src/main.nr",
      "source": "// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal NFT implementation with `AuthWit` support that allows minting in public-only and transfers in both public\n// and private.\n#[aztec]\npub contract NFT {\n    use crate::types::nft_note::{NFTNote, PartialNFTNote};\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::aztec::{\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        note::{constants::MAX_NOTES_PER_PAGE, note_interface::NoteProperties},\n        prelude::{\n            AztecAddress, Map, NoteGetterOptions, NoteViewerOptions, PrivateContext, PrivateSet,\n            PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::traits::Serialize,\n        utils::comparison::Comparator,\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use aztec::protocol_types::traits::ToField;\n    use std::meta::derive;\n\n    // docs:end:imports\n\n    // TODO(#8467): Rename this to Transfer - calling this NFTTransfer to avoid export conflict with the Transfer event\n    // in the Token contract.\n    #[derive(Serialize)]\n    #[event]\n    struct NFTTransfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        token_id: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // The symbol of the NFT\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        // The name of the NFT\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // The admin of the contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Addresses that can mint\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // Contains the NFTs owned by each address in private.\n        private_nfts: Map<AztecAddress, PrivateSet<NFTNote, Context>, Context>,\n        // A map from token ID to a boolean indicating if the NFT exists.\n        nft_exists: Map<Field, PublicMutable<bool, Context>, Context>,\n        // A map from token ID to the public owner of the NFT.\n        public_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.admin.write(new_admin);\n    }\n    // docs:end:set_admin\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.minters.at(minter).write(approve);\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint\n    #[public]\n    fn mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not a minter\");\n        assert(storage.nft_exists.at(token_id).read() == false, \"token already exists\");\n\n        storage.nft_exists.at(token_id).write(true);\n\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:mint\n\n    #[public]\n    #[view]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid owner\");\n\n        public_owners_storage.write(to);\n    }\n    // docs:end:transfer_in_public\n\n    // Transfers token with `token_id` from public balance of message sender to a private balance of `to`.\n    // docs:start:transfer_to_private\n    #[private]\n    fn transfer_to_private(to: AztecAddress, token_id: Field) {\n        let from = context.msg_sender();\n\n        let nft = NFT::at(context.this_address());\n\n        // We prepare the private balance increase.\n        let partial_note = _prepare_private_balance_increase(to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own NFTs.\n        nft._finalize_transfer_to_private_unsafe(from, token_id, partial_note).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_private\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// `finalize_transfer_to_private` with the returned partial note.\n    // docs:start:prepare_private_balance_increase\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress) -> PartialNFTNote {\n        _prepare_private_balance_increase(to, &mut context, storage)\n    }\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> PartialNFTNote {\n        // We create a partial note with unpopulated/zero token id for 'to'\n        let partial_note = NFTNote::partial(\n            to,\n            storage.private_nfts.at(to).storage_slot,\n            context,\n            to,\n            context.msg_sender(),\n        );\n\n        NFT::at(context.this_address())._store_nft_set_partial_note(partial_note).enqueue(context);\n\n        partial_note\n    }\n    // docs:end:prepare_private_balance_increase\n\n    // docs:start:store_payload_in_transient_storage_unsafe\n    #[public]\n    #[internal]\n    fn _store_nft_set_partial_note(partial_note: PartialNFTNote) {\n        // We store the partial note in a slot equal to its commitment. This is safe because the commitment is computed\n        // using a generator different from the one used to compute storage slots, so there can be no collisions.\n        // We could consider storing all pending partial notes in e.g. some array, but ultimately this is pointless: all\n        // we need to verify is that the note is valid.\n        context.storage_write(partial_note.commitment(), true);\n    }\n    // docs:end:store_payload_in_transient_storage_unsafe\n    /// Finalizes a transfer of NFT with `token_id` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `partial_note` must be passed as an argument to this function.\n    // docs:start:finalize_transfer_to_private\n    #[public]\n    fn finalize_transfer_to_private(token_id: Field, partial_note: PartialNFTNote) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n    ) {\n        _finalize_transfer_to_private(from, token_id, partial_note, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        token_id: Field,\n        partial_note: PartialNFTNote,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid NFT owner\");\n\n        // Set the public NFT owner to zero\n        public_owners_storage.write(AztecAddress::zero());\n\n        // We verify that the partial note we're completing is valid (i.e. it uses the correct state variable's storage\n        // slot, and it is internally consistent). We *could* clear the storage since each partial note should only be\n        // used once, but since the AVM offers no gas refunds for doing so this would just make the transaction be more\n        // expensive.\n        assert(context.storage_read(partial_note.commitment()), \"Invalid partial note\");\n        partial_note.complete(token_id, context);\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let nfts = storage.private_nfts;\n\n        let notes = nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring\");\n\n        let new_note = NFTNote::new(token_id, to);\n\n        nfts.at(to).insert(new_note).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let notes = storage.private_nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring to public\");\n\n        NFT::at(context.this_address())._finish_transfer_to_public(to, token_id).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:finish_transfer_to_public\n    #[public]\n    #[internal]\n    fn _finish_transfer_to_public(to: AztecAddress, token_id: Field) {\n        storage.public_owners.at(token_id).write(to);\n    }\n    // docs:end:finish_transfer_to_public\n\n    // Returns zero address when the token does not have a public owner. Reverts if the token does not exist.\n    #[public]\n    #[view]\n    fn owner_of(token_id: Field) -> AztecAddress {\n        assert(storage.nft_exists.at(token_id).read(), \"token does not exist\");\n        storage.public_owners.at(token_id).read()\n    }\n\n    /// Returns an array of token IDs owned by `owner` in private and a flag indicating whether a page limit was\n    /// reached. Starts getting the notes from page with index `page_index`. Zero values in the array are placeholder\n    /// values for non-existing notes.\n    // docs:start:get_private_nfts\n    unconstrained fn get_private_nfts(\n        owner: AztecAddress,\n        page_index: u32,\n    ) -> pub ([Field; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.private_nfts.at(owner).view_notes(options.set_offset(offset));\n\n        let mut owned_nft_ids = [0; MAX_NOTES_PER_PAGE];\n        for i in 0..options.limit {\n            if i < notes.len() {\n                owned_nft_ids[i] = notes.get_unchecked(i).token_id;\n            }\n        }\n\n        let page_limit_reached = notes.len() == options.limit;\n        (owned_nft_ids, page_limit_reached)\n    }\n    // docs:end:get_private_nfts\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/Users/sebastiansalazar/Documents/aizktec-Core/aizktec/packages/aztec/contracts/nft_contract/src/types/nft_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize},\n        utils::arrays::array_concat,\n    },\n};\n\n// NFTNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the token id).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n// docs:start:nft_note\n/// A private note representing a token id associated to an account.\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct NFTNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The ID of the token represented by this note.\n    token_id: Field,\n}\n// docs:end:nft_note\n\nimpl NoteHash for NFTNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because NFTNote has just one variant (where the token id is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            NFTPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note =\n            PartialNFTNote { commitment: private_content.compute_partial_commitment(storage_slot) };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.token_id)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { token_id, owner, randomness }\n    }\n\n    pub fn get_token_id(self) -> Field {\n        self.token_id\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the token id, since the note will be\n    /// later completed in public. This is a powerful technique for scenarios in which the token id cannot be known in\n    /// private (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialNFTNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note cration process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialNFTNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = NFTPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialNFTNote { commitment }\n    }\n}\n\n/// The private content of a partial NFTNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct NFTPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of NFTNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NFTPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateNFTPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of NFTNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateNFTPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        NFTNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a NFTNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the token id field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the tolken id to the public), resulting in a NFTNote that can be used like any other one (except\n/// of course that its token id is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialNFTNote {\n    commitment: Field,\n}\n\nimpl PartialNFTNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialNFTNote {\n    /// Completes the partial note, creating a new note that can be used like any other NFTNote.\n    pub fn complete(self, token_id: Field, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the token id). The contract will later find it by\n        //  searching for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(token_id));\n        context.push_note_hash(self.compute_complete_note_hash(token_id));\n    }\n\n    fn compute_note_completion_log(self, token_id: Field) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, token_id]\n    }\n\n    fn compute_complete_note_hash(self, token_id: Field) -> Field {\n        // Here we finalize the note hash by including the (public) token id into the partial note commitment. Note that\n        // we use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator([self.commitment, token_id], GENERATOR_INDEX__NOTE_HASH)\n    }\n}\n\nmod test {\n    use super::{\n        NFTNote, NFTPartialNotePrivateContent, PartialNFTNote,\n        PrivateNFTPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global token_id: Field = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a NFTNote has the same note hash as a PartialNFTNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = NFTNote { token_id, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialNFTNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(token_id);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular NFTNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular NFTNote.\n\n        let note = NFTNote { token_id, randomness, owner };\n\n        let partial_note_private_content = NFTPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateNFTPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialNFTNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(token_id)[0],\n        );\n\n        // Then we exctract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in NFTNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(token_id), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "66": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "74": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "75": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "82": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "83": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "84": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "85": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "87": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "88": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "89": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "90": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "91": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "97": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "99": {
      "path": "/Users/sebastiansalazar/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::encrypt_log,\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n/*\n * WHY IS THERE LOTS OF CODE DUPLICATION BETWEEN event.nr and note.nr?\n * It's because there are a few more optimisations that can be done for notes,\n * and so the stuff that looks like duplicated code currently, won't be\n * the same for long.\n * To modularise now feels premature, because we might get that modularisation wrong.\n * Much better (imo) to have a flattened templates for log assembly, because it\n * makes it much easier for us all to follow, it serves as a nice example for the\n * community to follow (if they wish to roll their own log layouts), and it gives\n * us more time to spot common patterns across all kinds of log layouts.\n */\n\n/*\n * LOG CONFIGURATION CHOICES:\n *\n * deliver_to: INPUT as recipient: AztecAddress\n * encrypt_with: aes128 CBC (Cipher Block Chaining)\n * shared_secret: ephemeral\n * shared_secret_randomness_extraction_hash: sha256\n * tag: true\n * tag_from: INPUT as sender: AztecAddress\n *\n * Note-specific:\n * derive_note_randomness_from_shared_secret: false\n *\n */\n\n/*\n * LOG LAYOUT CHOICE:\n *\n * Short explanation:\n * log = [tag, epk, header_ct=[[contract_address, ct_len], pkcs7_pad], ct=[[pt], pkcs7_pad], some bytes padding, some fields padding]\n *\n * Long explanation:\n * tag: Field\n * epk: [Field, u8]\n * header_ct: [[u8; 32], [u8; 2], [u8; 16]]\n * ct: [[u8; 2], [u8; x], [u8; y]]\n *\n * More precisely (in pseudocode):\n *\n * log = [\n *     tag: Field,\n *     Epk: Field,\n *\n *     le_bytes_31_to_fields(\n *\n *         log_bytes: [\n *             eph_pk_sign: [u8; 1],\n *\n *             header_ciphertext: aes_encrypt(\n *                 contract_address: [u8; 32],\n *                 ct_length: [u8; 2],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 header_pt_aes_padding: [u8; 14], // `16 - (input.len() % 16)`\n\n *             ): [u8; 48],\n *\n *             ciphertext: aes_encrypt(\n *                 final_pt: [\n *                     pt: {\n *                         note_bytes: {\n *                             storage_slot: [u8; 32],\n *                             note_type_id: [u8; 32],\n *                             ...note: [u8; N * 32],\n *                         }: [u8; N * 32 + 64],\n *                     }: [u8; N * 32 + 64],\n\n *                 ]: [u8; N * 32 + 64],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 pt_aes_padding: [u8; 16 - ( (|pt_length| + |pt|) % 16 )]\n *\n *             ): [u8; |pt| + |pt_aes_padding|]\n *                [u8; |ct|]\n *\n *             log_bytes_padding_to_mult_31: [u8; 31 * ceil((1 + 48 + |ct|)/31) - (1 + 48 + |ct|)],\n *                                           [u8; p]\n *\n *         ]: [u8; 1 + 48 + |ct| + p]\n *\n *     ): [Field; (1 + 48 + |ct| + p) / 31]\n *\n *     log_fields_padding: [Field; PRIVATE_LOG_SIZE_IN_FIELDS - 2 - (1 + 48 + |ct| + p) / 31],\n *\n * ]: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\n *\n *\n */\n\n/********************************************************/\n// End of disgusting arithmetic on generics\n/********************************************************/\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\n/// This particular log assembly strategy (AES 128) requires the note (and the\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\n/// operates on bytes; not fields.\n/// NB: The \"2\" in \"N + 2\" is for the note_id and the storage_slot of the note:\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> [Field; (N + 2)]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    let mut fields = [0; N + 2];\n    fields[0] = storage_slot;\n    fields[1] = Note::get_id(); // Note that the note id only uses 7 bits of this field.\n    for i in 0..packed_note.len() {\n        fields[i + 2] = packed_note[i];\n    }\n\n    fields\n}\n\npub fn compute_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let final_plaintext = compute_note_plaintext_for_this_strategy(note, storage_slot);\n\n    encrypt_log(context.this_address(), final_plaintext, recipient, sender)\n}\n\npub unconstrained fn compute_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(context, note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_log(*context, note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explainted on its description.\n        let encrypted_log =\n            unsafe { compute_log_unconstrained(*context, note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    }
  }
}
